
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="mlir.html">
      
      
        <link rel="next" href="mlir-onnx.html">
      
      <link rel="icon" href="../images/favicon.ico">
      <meta name="generator" content="mkdocs-1.4.3, mkdocs-material-9.1.11">
    
    
      
        <title>mlir-toy - Cat538's Blog</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.85bb2934.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.a6bdf11c.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../stylesheets/extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#mlir-toy-example" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../index.html" title="Cat538&#39;s Blog" class="md-header__button md-logo" aria-label="Cat538's Blog" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Cat538's Blog
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              mlir-toy
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
          
            
            
            
            <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
            
              <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
              </label>
            
          
            
            
            
            <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_2">
            
              <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12c0-2.42-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
              </label>
            
          
        </form>
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../index.html" title="Cat538&#39;s Blog" class="md-nav__button md-logo" aria-label="Cat538's Blog" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Cat538's Blog
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../index.html" class="md-nav__link">
        Prologue
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../plan.html" class="md-nav__link">
        Exercise
      </a>
    </li>
  

    
      
      
      

  
  
  
    
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
          Cpp
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          Cpp
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../cpp/toolchain.html" class="md-nav__link">
        toolchain
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../cpp/move.html" class="md-nav__link">
        move
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../cpp/align.html" class="md-nav__link">
        align
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../cpp/ranges.html" class="md-nav__link">
        ranges
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../cpp/benchmark.html" class="md-nav__link">
        benchmark
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../cpp/profiler.html" class="md-nav__link">
        profiler
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../cpp/IO-multiplexing.html" class="md-nav__link">
        IO-multiplexing
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../cpp/epoll.html" class="md-nav__link">
        epoll
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../cpp/signal.html" class="md-nav__link">
        signal
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../cpp/fork-safe.html" class="md-nav__link">
        fork-safe
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
          Rust
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          Rust
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../rust/rust-toolchain.html" class="md-nav__link">
        rust-toolchain
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../rust/rust-study.html" class="md-nav__link">
        rust-study
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../rust/rust-attributes.html" class="md-nav__link">
        rust-attributes
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../rust/rust-modules.html" class="md-nav__link">
        rust-modules
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../rust/rust-macro.html" class="md-nav__link">
        rust-macro
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../rust/rust-network.html" class="md-nav__link">
        rust-network
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../rust/rust-option.html" class="md-nav__link">
        rust-optin
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../rust/rust-str.html" class="md-nav__link">
        rust-str
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
          Tools
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          Tools
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../tools/cmake.html" class="md-nav__link">
        cmake
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../tools/docker.html" class="md-nav__link">
        docker
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../tools/git.html" class="md-nav__link">
        git
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../tools/powershell.html" class="md-nav__link">
        powershell
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../tools/regex.html" class="md-nav__link">
        regex
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../tools/mkdocs.html" class="md-nav__link">
        mkdocs
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
      
      
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
          Courses
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          Courses
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../courses/%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90%E5%AD%A6%E5%A4%8D%E4%B9%A0.html" class="md-nav__link">
        密码分析学
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../courses/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%BC%95%E8%AE%BA%E5%A4%8D%E4%B9%A0.html" class="md-nav__link">
        密码学引论
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../courses/algorithm.html" class="md-nav__link">
        算法设计与分析
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../courses/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.html" class="md-nav__link">
        编译原理
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
      
      
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_7" id="__nav_7_label" tabindex="0">
          Crypto
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_7">
          <span class="md-nav__icon md-icon"></span>
          Crypto
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../crypto/ecdsa-pk-recovery.html" class="md-nav__link">
        ecdsa-pk-recovery
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../crypto/algo-rsa.html" class="md-nav__link">
        algo-rsa
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../crypto/algo-fft%26ntt.html" class="md-nav__link">
        algo-fft&ntt
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../crypto/algo-reduction.html" class="md-nav__link">
        algo-reduction
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
      
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" checked>
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="0">
          Mlc
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="true">
        <label class="md-nav__title" for="__nav_8">
          <span class="md-nav__icon md-icon"></span>
          Mlc
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="dlc-survey.html" class="md-nav__link">
        dlc-survey
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="tvm-install.html" class="md-nav__link">
        tvm-install
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="tvm-ffi.html" class="md-nav__link">
        tvm-ffi
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="tvm-type.html" class="md-nav__link">
        tvm-type
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="tvm-tensorIR.html" class="md-nav__link">
        tvm-tensorIR
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="tvm-lowering.html" class="md-nav__link">
        tvm-lowering
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="tvm-autotvm.html" class="md-nav__link">
        tvm-autotvm
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="tvm-ansor.html" class="md-nav__link">
        tvm-ansor
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="mlir.html" class="md-nav__link">
        mlir
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          mlir-toy
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="mlir-toy.html" class="md-nav__link md-nav__link--active">
        mlir-toy
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1-chapter1-toy-ast" class="md-nav__link">
    1. Chapter1: Toy 语言和 AST
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-chapter2-mlir" class="md-nav__link">
    2. Chapter2. 生成初级 MLIR
  </a>
  
    <nav class="md-nav" aria-label="2. Chapter2. 生成初级 MLIR">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21-toy-dialect" class="md-nav__link">
    2.1. 定义一个 Toy Dialect
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-chapter-3-high-level" class="md-nav__link">
    3. Chapter 3: High-level 分析和转换
  </a>
  
    <nav class="md-nav" aria-label="3. Chapter 3: High-level 分析和转换">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-c-pass" class="md-nav__link">
    3.1. 使用 C++ 写 pass
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-drr-pass" class="md-nav__link">
    3.2. 使用 DRR 写 pass
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-chapter-4-interfaces-transformation" class="md-nav__link">
    4. Chapter 4: 使用 Interfaces 泛化 Transformation
  </a>
  
    <nav class="md-nav" aria-label="4. Chapter 4: 使用 Interfaces 泛化 Transformation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#42-pass" class="md-nav__link">
    4.2. 形状传播 pass
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-chapter-5-lowering-lower-level-dialects" class="md-nav__link">
    5. Chapter 5: 部分 Lowering 到 Lower-Level Dialects 做优化
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-chapter-6-lowering-to-llvm-and-codegeneration" class="md-nav__link">
    6. Chapter 6: Lowering to LLVM and CodeGeneration
  </a>
  
    <nav class="md-nav" aria-label="6. Chapter 6: Lowering to LLVM and CodeGeneration">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#61-lowering-toyprint" class="md-nav__link">
    6.1. Lowering toy.print
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#62-llvm-ir-jit" class="md-nav__link">
    6.2. 生成LLVM IR 并 JIT
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7-chapter-7-toy" class="md-nav__link">
    7. Chapter 7: 为 Toy 添加复合类型
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="mlir-onnx.html" class="md-nav__link">
        mlir-onnx
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="mlir-iree.html" class="md-nav__link">
        mlir-iree
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="paper-torch.fx.html" class="md-nav__link">
        paper-torch.fx
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="paper-nimble.html" class="md-nav__link">
        paper-nimble
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="paper-disc.html" class="md-nav__link">
        paper-disc
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="paper-cortex.html" class="md-nav__link">
        paper-cortex
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="paper-freetensor.html" class="md-nav__link">
        paper-freetensor
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../about.html" class="md-nav__link">
        About
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1-chapter1-toy-ast" class="md-nav__link">
    1. Chapter1: Toy 语言和 AST
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-chapter2-mlir" class="md-nav__link">
    2. Chapter2. 生成初级 MLIR
  </a>
  
    <nav class="md-nav" aria-label="2. Chapter2. 生成初级 MLIR">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21-toy-dialect" class="md-nav__link">
    2.1. 定义一个 Toy Dialect
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-chapter-3-high-level" class="md-nav__link">
    3. Chapter 3: High-level 分析和转换
  </a>
  
    <nav class="md-nav" aria-label="3. Chapter 3: High-level 分析和转换">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-c-pass" class="md-nav__link">
    3.1. 使用 C++ 写 pass
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-drr-pass" class="md-nav__link">
    3.2. 使用 DRR 写 pass
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-chapter-4-interfaces-transformation" class="md-nav__link">
    4. Chapter 4: 使用 Interfaces 泛化 Transformation
  </a>
  
    <nav class="md-nav" aria-label="4. Chapter 4: 使用 Interfaces 泛化 Transformation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#42-pass" class="md-nav__link">
    4.2. 形状传播 pass
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-chapter-5-lowering-lower-level-dialects" class="md-nav__link">
    5. Chapter 5: 部分 Lowering 到 Lower-Level Dialects 做优化
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-chapter-6-lowering-to-llvm-and-codegeneration" class="md-nav__link">
    6. Chapter 6: Lowering to LLVM and CodeGeneration
  </a>
  
    <nav class="md-nav" aria-label="6. Chapter 6: Lowering to LLVM and CodeGeneration">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#61-lowering-toyprint" class="md-nav__link">
    6.1. Lowering toy.print
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#62-llvm-ir-jit" class="md-nav__link">
    6.2. 生成LLVM IR 并 JIT
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7-chapter-7-toy" class="md-nav__link">
    7. Chapter 7: 为 Toy 添加复合类型
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="mlir-toy-example">MLIR-TOY Example</h1>
<blockquote>
<p><strong>Ref</strong>:</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/102212806">MLIR的法宝：Dialects</a></li>
<li><a href="http://giantpandacv.com/project/%E9%83%A8%E7%BD%B2%E4%BC%98%E5%8C%96/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BC%96%E8%AF%91%E5%99%A8/%E3%80%90%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%91%E5%8D%81%E4%BA%8C%EF%BC%8CMLIR%20Toy%20Tutorials%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/">【从零开始学深度学习编译器】十二，MLIR</a></li>
</ul>
</blockquote>
<h2 id="1-chapter1-toy-ast">1. Chapter1: Toy 语言和 AST</h2>
<p>这个教程用的是kaleidoscope 的变形， 一个例子如下：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># RUN: toyc-ch1 %s -emit=ast 2&gt;&amp;1 | FileCheck %**s**</span>

<span class="c1"># User defined function that 操作 **任意** 形状的参数（类比 function template）</span>
<span class="k">def</span> <span class="nf">multiply_transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">transpose</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1"># `a` shape &lt;2, 3&gt;; 其 shape 从字面量推断而来</span>
  <span class="n">var</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]];</span>
  <span class="c1"># b 与 a 完全相同, literal array is **implicitly reshaped**</span>
  <span class="n">var</span> <span class="n">b</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">];</span>

  <span class="c1"># This call will specialize `multiply_transpose` with &lt;2, 3&gt; for both</span>
  <span class="c1"># arguments and deduce a return type of &lt;2, 2&gt; in initialization of `c`.</span>
  <span class="n">var</span> <span class="n">c</span> <span class="o">=</span> <span class="n">multiply_transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="c1"># A second call to `multiply_transpose` with &lt;2, 3&gt; for both arguments will</span>
  <span class="c1"># reuse the previously specialized and inferred version and return `&lt;2, 2&gt;`</span>
  <span class="n">var</span> <span class="n">d</span> <span class="o">=</span> <span class="n">multiply_transpose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
  <span class="c1"># A new call with `&lt;2, 2&gt;` for both dimension will trigger another</span>
  <span class="c1"># specialization of `multiply_transpose`.</span>
  <span class="n">var</span> <span class="n">e</span> <span class="o">=</span> <span class="n">multiply_transpose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
  <span class="c1"># call `multiply_transpose` with 不匹配的 shape will 导致一个 inference error</span>
  <span class="n">var</span> <span class="n">f</span> <span class="o">=</span> <span class="n">multiply_transpose</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>执行<code>.\bin\toyc-ch1 ..\mlir\test\Examples\Toy\Ch1\ast.toy -emit=ast</code></p>
<p>上面 Toy 程序产生的 AST(去掉源码位置信息):</p>
<div class="highlight"><pre><span></span><code><span class="nl">Module</span><span class="p">:</span>
<span class="n">Function</span>
<span class="w">    </span><span class="n">Proto</span><span class="w"> </span><span class="err">&#39;</span><span class="n">multiply_transpose</span><span class="err">&#39;</span><span class="w"> </span>
<span class="w">    </span><span class="nl">Params</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">]</span>
<span class="w">    </span><span class="n">Block</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Return</span>
<span class="w">        </span><span class="nl">BinOp</span><span class="p">:</span><span class="w"> </span><span class="o">*</span><span class="w"> </span>
<span class="w">        </span><span class="n">Call</span><span class="w"> </span><span class="err">&#39;</span><span class="n">transpose</span><span class="err">&#39;</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">var</span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">]</span>
<span class="w">        </span><span class="n">Call</span><span class="w"> </span><span class="err">&#39;</span><span class="n">transpose</span><span class="err">&#39;</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">var</span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">]</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// Block</span>
<span class="n">Function</span>
<span class="w">    </span><span class="n">Proto</span><span class="w"> </span><span class="err">&#39;</span><span class="n">main</span><span class="err">&#39;</span><span class="w"> </span>
<span class="w">    </span><span class="nl">Params</span><span class="p">:</span><span class="w"> </span><span class="p">[]</span>
<span class="w">    </span><span class="n">Block</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VarDecl</span><span class="w"> </span><span class="n">a</span><span class="o">&lt;&gt;</span><span class="w"> </span>
<span class="w">        </span><span class="nl">Literal</span><span class="p">:</span><span class="w"> </span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="w"> </span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="w"> </span><span class="mf">1.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">2.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">3.000000e+00</span><span class="p">],</span><span class="w"> </span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="w"> </span><span class="mf">4.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">5.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">6.000000e+00</span><span class="p">]]</span><span class="w"> </span>
<span class="w">    </span><span class="n">VarDecl</span><span class="w"> </span><span class="n">b</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span>
<span class="w">        </span><span class="nl">Literal</span><span class="p">:</span><span class="w"> </span><span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span><span class="p">[</span><span class="w"> </span><span class="mf">1.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">2.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">3.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">4.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">5.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">6.000000e+00</span><span class="p">]</span><span class="w"> </span>
<span class="w">    </span><span class="n">VarDecl</span><span class="w"> </span><span class="n">c</span><span class="o">&lt;&gt;</span><span class="w"> </span>
<span class="w">        </span><span class="n">Call</span><span class="w"> </span><span class="err">&#39;</span><span class="n">multiply_transpose</span><span class="err">&#39;</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">var</span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">var</span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">]</span>
<span class="w">    </span><span class="n">VarDecl</span><span class="w"> </span><span class="n">d</span><span class="o">&lt;&gt;</span><span class="w"> </span>
<span class="w">        </span><span class="n">Call</span><span class="w"> </span><span class="err">&#39;</span><span class="n">multiply_transpose</span><span class="err">&#39;</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">var</span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">var</span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">]</span>
<span class="w">    </span><span class="n">VarDecl</span><span class="w"> </span><span class="n">e</span><span class="o">&lt;&gt;</span><span class="w"> </span>
<span class="w">        </span><span class="n">Call</span><span class="w"> </span><span class="err">&#39;</span><span class="n">multiply_transpose</span><span class="err">&#39;</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">var</span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">var</span><span class="o">:</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">]</span>
<span class="w">    </span><span class="n">VarDecl</span><span class="w"> </span><span class="n">f</span><span class="o">&lt;&gt;</span><span class="w"> </span>
<span class="w">        </span><span class="n">Call</span><span class="w"> </span><span class="err">&#39;</span><span class="n">multiply_transpose</span><span class="err">&#39;</span><span class="w"> </span><span class="p">[</span><span class="w"> </span>
<span class="w">            </span><span class="n">Call</span><span class="w"> </span><span class="err">&#39;</span><span class="n">transpose</span><span class="err">&#39;</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">var</span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">]</span>
<span class="w">            </span><span class="nl">var</span><span class="p">:</span><span class="w"> </span><span class="n">c</span><span class="w"> </span>
<span class="w">        </span><span class="p">]</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// Block</span>
</code></pre></div>
<h2 id="2-chapter2-mlir">2. Chapter2. 生成初级 MLIR</h2>
<p>首先说了编译器领域的软件碎片化问题：</p>
<blockquote>
<p>像 LLVM 这种编译器， 提供了a fixed set of predefined types and (usually low-level / RISC-like) instructions。 但尽管不同的前端可以重用LLVM，生成LLVMIR这一统一的中间表示，但是 像C++ 这样的语言需要自己实现 high level AST(例如 clang AST, Rust AST)， 完成语言特定的类型检查、分析(如C++的模板特化，Rust的生命周期检查)等。 </p>
<p>最终每一门高级语言都要去设计实现一套自己的AST， 尽管这些AST在很多地方相似，尽管再这些AST上的优化很类似，但是彼此之间无法重用，造成软件碎片化。 </p>
<p>MLIR 天生为可扩展、可重用而设计， MLIR中有很少的内置类型和指令， 即所谓的 (little builtin, everything customizable) 设计原则。它的愿景是提供一套构建IR的基础设施， 即使用MLIR 来构建IR， 这样不同的IR 之间有差异，但是能共用很多部分，能利用已经充分成熟的编译器领域的成果和这么多年积累下来的最佳实践，而不是去重复"发明"一些"新技术"出来。</p>
<p>the system should encourage one to design reusable abstractions and assume they will be used outside of their initial scope.</p>
</blockquote>
<p>上面提到 MLIR 被设计为可扩展的基础设施，没有封闭的属性集，类型集，操作集； MLIR 通过 方言 Dialects 的概念来支持这种可扩展性。 <strong>一个 Dialect 就是用户(或者MLIR预定义)在一个命名空间下提供的一组抽象</strong>， 通过 Dialect 来统一不同级别的IR。</p>
<p>首先看一个 Dialect 的例子： 执行 chapter2 的程序: <code>./bin/toyc-ch2 ../mlir/test/Examples/Toy/Ch2/codegen.toy -emit=mlir -mlir-print-debuginfo</code> 得到第一章中程序示例的 <strong>Toy Dialect 表示</strong>如下（下面的代码删除掉了 debug-info ）</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">toy</span><span class="p">.</span><span class="n">func</span><span class="w"> </span><span class="err">@</span><span class="n">multiply_transpose</span><span class="p">(</span><span class="o">%</span><span class="n">arg0</span><span class="o">:</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;*</span><span class="n">xf64</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="n">arg1</span><span class="o">:</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;*</span><span class="n">xf64</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;*</span><span class="n">xf64</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 1. 转置两个输入矩阵</span>
<span class="w">    </span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">toy</span><span class="p">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">%</span><span class="n">arg0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;*</span><span class="n">xf64</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;*</span><span class="n">xf64</span><span class="o">&gt;</span>
<span class="w">    </span><span class="o">%</span><span class="mi">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">toy</span><span class="p">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">%</span><span class="n">arg1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;*</span><span class="n">xf64</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;*</span><span class="n">xf64</span><span class="o">&gt;</span>
<span class="w">    </span><span class="c1">// 2. 相乘</span>
<span class="w">    </span><span class="o">%</span><span class="mi">2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">toy</span><span class="p">.</span><span class="n">mul</span><span class="w"> </span><span class="o">%</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;*</span><span class="n">xf64</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">toy</span><span class="p">.</span><span class="k">return</span><span class="w"> </span><span class="o">%</span><span class="mi">2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;*</span><span class="n">xf64</span><span class="o">&gt;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">toy</span><span class="p">.</span><span class="n">func</span><span class="w"> </span><span class="err">@</span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// var a&lt;2, 3&gt; = [[1, 2, 3], [4, 5, 6]];</span>
<span class="w">    </span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">toy</span><span class="p">.</span><span class="n">constant</span><span class="w"> </span><span class="n">dense</span><span class="o">&lt;</span><span class="p">[[</span><span class="mf">1.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">2.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">3.000000e+00</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mf">4.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">5.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">6.000000e+00</span><span class="p">]]</span><span class="o">&gt;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;</span><span class="mi">2</span><span class="n">x3xf64</span><span class="o">&gt;</span>
<span class="w">    </span><span class="o">%</span><span class="mi">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">toy</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;</span><span class="mi">2</span><span class="n">x3xf64</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;</span><span class="mi">2</span><span class="n">x3xf64</span><span class="o">&gt;</span>
<span class="w">    </span><span class="c1">// var b&lt;2, 3&gt; = [1, 2, 3, 4, 5, 6];</span>
<span class="w">    </span><span class="o">%</span><span class="mi">2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">toy</span><span class="p">.</span><span class="n">constant</span><span class="w"> </span><span class="n">dense</span><span class="o">&lt;</span><span class="p">[</span><span class="mf">1.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">2.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">3.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">4.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">5.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">6.000000e+00</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;</span><span class="mi">6</span><span class="n">xf64</span><span class="o">&gt;</span>
<span class="w">    </span><span class="o">%</span><span class="mi">3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">toy</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">%</span><span class="mi">2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;</span><span class="mi">6</span><span class="n">xf64</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;</span><span class="mi">2</span><span class="n">x3xf64</span><span class="o">&gt;</span>
<span class="w">    </span><span class="c1">// var c = multiply_transpose(a, b);</span>
<span class="w">    </span><span class="c1">// var d = multiply_transpose(b, a);</span>
<span class="w">    </span><span class="o">%</span><span class="mi">4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">toy</span><span class="p">.</span><span class="n">generic_call</span><span class="w"> </span><span class="err">@</span><span class="n">multiply_transpose</span><span class="p">(</span><span class="o">%</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">tensor</span><span class="o">&lt;</span><span class="mi">2</span><span class="n">x3xf64</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;</span><span class="mi">2</span><span class="n">x3xf64</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;*</span><span class="n">xf64</span><span class="o">&gt;</span>
<span class="w">    </span><span class="o">%</span><span class="mi">5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">toy</span><span class="p">.</span><span class="n">generic_call</span><span class="w"> </span><span class="err">@</span><span class="n">multiply_transpose</span><span class="p">(</span><span class="o">%</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">tensor</span><span class="o">&lt;</span><span class="mi">2</span><span class="n">x3xf64</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;</span><span class="mi">2</span><span class="n">x3xf64</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;*</span><span class="n">xf64</span><span class="o">&gt;</span>
<span class="w">    </span><span class="c1">// print(d);</span>
<span class="w">    </span><span class="n">toy</span><span class="p">.</span><span class="n">print</span><span class="w"> </span><span class="o">%</span><span class="mi">5</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;*</span><span class="n">xf64</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">toy</span><span class="p">.</span><span class="k">return</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>在 MLIR 中， <code>Operations</code> 是抽象和计算的核心， MLIR 中的 instructions, functions, modules 都使用 <code>Operation</code> 来表示。 以上面 MLIR toy dialect 中的 <code>transpose</code> 操作为例，来看看 MLIR 表达式是由什么组成的： <code>transpose(a)</code> 的 MLIR 表达式由操作结果名称、Dialect命名空间、操作名、参数列表、输入参数类型、输出类型和操作在源文件中的位置组成。</p>
<div class="highlight"><pre><span></span><code><span class="o">%</span><span class="n">t_tensor</span> <span class="o">=</span> <span class="s2">&quot;toy.transpose&quot;</span><span class="p">(</span><span class="o">%</span><span class="n">tensor</span><span class="p">)</span> <span class="p">{</span><span class="n">inplace</span> <span class="o">=</span> <span class="n">true</span><span class="p">}</span> <span class="p">:</span> <span class="p">(</span><span class="n">tensor</span><span class="o">&lt;</span><span class="mi">2</span><span class="n">x3xf64</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tensor</span><span class="o">&lt;</span><span class="mi">3</span><span class="n">x2xf64</span><span class="o">&gt;</span> <span class="n">loc</span><span class="p">(</span><span class="s2">&quot;example/file/path&quot;</span><span class="p">:</span><span class="mi">12</span><span class="p">:</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div>
<ul>
<li><code>%t_tensor</code>：这个 Operation 定义的结果的名字，前面的%是避免冲突，见 https://mlir.llvm.org/docs/LangRef/#identifiers-and-keywords 。一个 Operation 可以定义 0 或者多个结果（在 Toy 语言中，只有单结果的 Operation），它们是 SSA 值。该名称在解析期间使用，但不是持久的（例如，它不会在 SSA 值的内存表示中进行跟踪）。</li>
<li><code>"toy.transpose"</code> ：Operation 的名字。它应该是一个唯一的字符串，Dialect 的命名空间前缀为 <code>.</code>。 这可以理解为 Toy Dialect 中的 transpose Operation。</li>
<li><code>(%tensor)</code>：零个或多个输入操作数（或参数）的列表，它们是由其它操作定义或引用块参数的 SSA 值。</li>
<li><code>{ inplace = true }</code>：零个或多个属性的字典，这些属性是始终为常量的特殊操作数。 在这里，我们定义了一个名为 <code>inplace</code> 的布尔属性，它的常量值为 true。</li>
<li><code>(tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;3x2xf64&gt;</code>：函数形式表示的操作类型，前者是输入，后者是输出。&lt;2x3xf64&gt;号中间的内容描述了张量的尺寸2x3和张量中存储的数据类型f64，中间使用x连接。</li>
<li><code>loc("example/file/path":12:1)</code>：此操作的源代码中的位置。<strong>需要注意的是</strong>： MLIR 中的 loc 信息（源码位置信息）在实际应用中是不能去除的， 这与 在 LLVM等其它编译器中 中附加的 Debug 信息不同。</li>
</ul>
<blockquote>
<p>In MLIR, every operation has a mandatory source location associated with it. Contrary to LLVM, where debug info locations are metadata and can be dropped, in MLIR, the location is a core requirement, and APIs depend on and manipulate it. Dropping a location is thus an explicit choice which cannot happen by mistake.
</p>
</blockquote>
<p>💡<u><strong>那我们的 <code>codegen.toy</code> 中的toy语言源码是怎么样转换成上面这个 Toy Dialect 的呢</strong></u>：</p>
<div class="autocb" style="text-align:center;"><img src="./mlir-toy.assets\autocb_0.png" style="zoom: 45%;box-shadow: rgba(0, 0, 0, 0.5) 10px 10px 10px; border-radius: 10px;" /></div>

<p>简单来说，我们遍历 toy 语言的 AST， 将对应的表达式 Expr 转换成 Toy dialect 中的 operation。就具体实现来说，从toy 语言的 AST(即 <code>toy::ModuleAST</code>) 到 MLIR 表达式(即<code>mlir::ModuleOp</code>) 的生成过程在函数 <code>dumpMLIR</code> 中实现。</p>
<blockquote>
<p>💡在继续接下来的内容之前， 先来看一下 MLIR Toy Example 的代码结构，以第二章为例：</p>
<ul>
<li>
<p><u><strong>include</strong></u></p>
<ul>
<li><strong>toy</strong><ul>
<li><code>Dialect.h</code>:  Toy Dialect 的定义， 以及 Toy Dialect 上的 Operation 的定义；实际上该文件只是简单的包含 由 tablegen 生成的代码</li>
<li><code>MLIRGen.h</code>:  声明了 <strong>从 Toy AST 生成 Toy Dialect 的接口 <code>mlirGen</code></strong></li>
<li><code>Ops.td</code>:     <strong>整个 Example 中最核心的部分</strong>， 声明了 Toy Dialect， 以及 Toy Dialect 上的 Operation； 将由 mlir-tablegen 生成c++ 代码</li>
<li><code>AST.h</code>:      Toy 语言的 AST 定义， 来自 <u>Kaleidoscope</u>， 不需要关心</li>
<li><code>Lexer.h</code>:    一个 Tokenizer 的实现，来自 <u>Kaleidoscope</u>， 不需要关心</li>
<li><code>Parser.h</code>:   一个递归下降 Parser，来自 <u>Kaleidoscope</u>， 不需要关心</li>
</ul>
</li>
</ul>
</li>
<li>
<p><u><strong>mlir</strong></u></p>
<ul>
<li><code>Dialect.cpp</code>:  <strong>从 Toy AST 生成 Toy Dialect 的具体实现</strong>， 主要在 <code>MLIRGenImpl</code> class 中实现， 这个类暴露一个 <code>mlir::ModuleOp mlirGen(ModuleAST &amp;moduleAST)</code> ；内部实现对每一种 Toy AST(如 ExprAST, FunctionAST 等) 的转换</li>
<li><code>MLIRGen.cpp</code>:  主要是 Toy Dialect 上的 Operation 的具体实现， 目前不是特别懂TODO； 还实现了每种 Operation 的 print 具体实现， 用于dump</li>
</ul>
</li>
<li><u><strong>parser</strong></u><ul>
<li><code>AST.cpp</code>:  Toy 语言的 AST 定义， 来自 <u>Kaleidoscope</u>， 不需要关心</li>
</ul>
</li>
<li><code>toyc.cpp</code>: toy 语言编译器的 cli， 实现了 <code>emit-MLIR</code> 和 <code>emit-AST</code> 等
</li>
</ul>
</blockquote>
<ol>
<li>
<p>dumpMLIR 实现在 <code>examples/toy/Ch2/toys.cpp</code> 中：</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">dumpMLIR</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">mlir</span><span class="o">::</span><span class="n">MLIRContext</span><span class="w"> </span><span class="n">context</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// 1. 将我们自定义的 toy Dialect 加载到这个 MLIR Context</span>
<span class="w">  </span><span class="n">context</span><span class="p">.</span><span class="n">getOrLoadDialect</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">toy</span><span class="o">::</span><span class="n">ToyDialect</span><span class="o">&gt;</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// 2. 从 cli 读取的 inputFilename 是 &#39;.toy&#39; 文件时， 调用 mlirGen</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">moduleAST</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parseInputFile</span><span class="p">(</span><span class="n">inputFilename</span><span class="p">);</span>
<span class="w">  </span><span class="n">mlir</span><span class="o">::</span><span class="n">OwningOpRef</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">ModuleOp</span><span class="o">&gt;</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mlirGen</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">moduleAST</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// 3. dump</span>
<span class="w">  </span><span class="k">module</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// 输入是 .mlir 等其它情况时；省略</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div>
</li>
<li>
<p>从上面可以看到，关键在于 <code>mlirGen</code> 方法，其实现在 文件 <code>examples/toy/Ch2/mlir/MLIRGen.cpp</code> 的 <code>MLIRGenImpl::mlirGen</code> 方法中:</p>
<div class="highlight"><pre><span></span><code><span class="c1">/// 使用 RTTI 判断表达式类型， Dispatch 到对应的 codegen 方法</span>
<span class="n">mlir</span><span class="o">::</span><span class="n">Value</span><span class="w"> </span><span class="nf">mlirGen</span><span class="p">(</span><span class="n">ExprAST</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">expr</span><span class="p">.</span><span class="n">getKind</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">toy</span><span class="o">::</span><span class="no">ExprAST</span><span class="o">::</span><span class="no">Expr_BinOp</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">mlirGen</span><span class="p">(</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">BinaryExprAST</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expr</span><span class="p">));</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">toy</span><span class="o">::</span><span class="no">ExprAST</span><span class="o">::</span><span class="no">Expr_Var</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">mlirGen</span><span class="p">(</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">VariableExprAST</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expr</span><span class="p">));</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">toy</span><span class="o">::</span><span class="no">ExprAST</span><span class="o">::</span><span class="no">Expr_Literal</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">mlirGen</span><span class="p">(</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">LiteralExprAST</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expr</span><span class="p">));</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">toy</span><span class="o">::</span><span class="no">ExprAST</span><span class="o">::</span><span class="no">Expr_Call</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">mlirGen</span><span class="p">(</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">CallExprAST</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expr</span><span class="p">));</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">toy</span><span class="o">::</span><span class="no">ExprAST</span><span class="o">::</span><span class="no">Expr_Num</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">mlirGen</span><span class="p">(</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">NumberExprAST</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expr</span><span class="p">));</span>
<span class="w">  </span><span class="k">default</span><span class="o">:</span>
<span class="w">    </span><span class="n">emitError</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
</li>
<li>
<p>codeGen 的具体过程就是遍历整个AST， 生成对应的 MLIR Operation， 插入到 <code>OpBuilder::block</code> 中。 下面是三个例子：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 1. 将 toy AST 中的 `NumberExprAST` 转成 `ConstantOp`</span>
<span class="n">mlir</span><span class="o">::</span><span class="n">Value</span><span class="w"> </span><span class="nf">mlirGen</span><span class="p">(</span><span class="n">NumberExprAST</span><span class="w"> </span><span class="o">&amp;</span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">create</span><span class="o">&lt;</span><span class="n">ConstantOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">loc</span><span class="p">(</span><span class="n">num</span><span class="p">.</span><span class="n">loc</span><span class="p">()),</span><span class="w"> </span><span class="n">num</span><span class="p">.</span><span class="n">getValue</span><span class="p">());</span>
<span class="p">}</span>
<span class="c1">// 2. 将 toy AST 中的 `BinaryExprAST` 转成 `AddOp` or `MulOp`</span>
<span class="n">mlir</span><span class="o">::</span><span class="n">Value</span><span class="w"> </span><span class="nf">mlirGen</span><span class="p">(</span><span class="n">BinaryExprAST</span><span class="w"> </span><span class="o">&amp;</span><span class="n">binop</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">mlir</span><span class="o">::</span><span class="n">Value</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mlirGen</span><span class="p">(</span><span class="o">*</span><span class="n">binop</span><span class="p">.</span><span class="n">getLHS</span><span class="p">());</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">lhs</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">  </span><span class="n">mlir</span><span class="o">::</span><span class="n">Value</span><span class="w"> </span><span class="n">rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mlirGen</span><span class="p">(</span><span class="o">*</span><span class="n">binop</span><span class="p">.</span><span class="n">getRHS</span><span class="p">());</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">binop</span><span class="p">.</span><span class="n">getOp</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="sc">&#39;+&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">create</span><span class="o">&lt;</span><span class="n">AddOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">loc</span><span class="p">(</span><span class="n">binop</span><span class="p">.</span><span class="n">loc</span><span class="p">()),</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="sc">&#39;*&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">create</span><span class="o">&lt;</span><span class="n">MulOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">loc</span><span class="p">(</span><span class="n">binop</span><span class="p">.</span><span class="n">loc</span><span class="p">()),</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 3. 将 toy AST 中的 `CallExprAST` 转成 `TransposeOp` 或其它 Op</span>
<span class="n">mlir</span><span class="o">::</span><span class="n">Value</span><span class="w"> </span><span class="nf">mlirGen</span><span class="p">(</span><span class="n">CallExprAST</span><span class="w"> </span><span class="o">&amp;</span><span class="n">call</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 首先为 operands 进行 Codegen</span>
<span class="w">  </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">Value</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operands</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">call</span><span class="p">.</span><span class="n">getArgs</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mlirGen</span><span class="p">(</span><span class="o">*</span><span class="n">expr</span><span class="p">);</span>
<span class="w">    </span><span class="n">operands</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Builtin calls </span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">call</span><span class="p">.</span><span class="n">getCallee</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;transpose&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">create</span><span class="o">&lt;</span><span class="n">TransposeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">loc</span><span class="p">(</span><span class="n">call</span><span class="p">.</span><span class="n">loc</span><span class="p">()),</span><span class="w"> </span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// 否则 this is a call to a user-defined function.</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div>
<p>过程中生成的 Operation 会按顺序被 insert 到 <code>mlir::OpBuilder::block</code> 中。 最终遍历生成的 MLIR Operation， 执行打印，就得到了上面打出来的 MLIR 表达式。 这里的问题是 <code>AddOp</code> <code>ConstantOp</code> 等 Op 是 toy dialect 中的内容， 因此我们需要实现定义这些数据结构， 那么具体该如何利用 MLIR 这个框架，去定义我们自己的 dialect 呢？</p>
</li>
</ol>
<h3 id="21-toy-dialect">2.1. 定义一个 Toy Dialect</h3>
<p>接下这部分是 官方文档翻译：</p>
<blockquote>
<p>💡<strong>定义一个 Toy Dialect</strong></p>
<p>为了有效地与MLIR交互，我们将定义一个新的toy方言。这种方言将模拟toy语言的结构，并为高级分析和转换提供一条简单的途径。</p>
<div class="highlight"><pre><span></span><code><span class="c1">/// Toy dialect 继承自 mlir::Dialect</span>
<span class="c1">/// 并且 在构造函数中 registers 一系列自定义的 属性、操作、类型</span>
<span class="c1">/// 它也可以通过重写一些 virtual methods 改变一些 general behavior</span>
<span class="c1">/// (在下一个 chapter 中将会讨论)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ToyDialect</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">mlir</span><span class="o">::</span><span class="n">Dialect</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">explicit</span><span class="w"> </span><span class="n">ToyDialect</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="p">);</span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">StringRef</span><span class="w"> </span><span class="nf">getDialectNamespace</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;toy&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>现在可以在全局注册表中注册该方言：</p>
<div class="highlight"><pre><span></span><code><span class="n">mlir</span><span class="o">::</span><span class="n">registerDialect</span><span class="o">&lt;</span><span class="n">ToyDialect</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div>
<p><strong>从现在开始创建的任何新的 <code>MLIRContext</code> 都将包含toy方言的一个实例</strong>，并调用特定的 hooks 来解析属性和类型。</p>
<hr />
<p>💡<strong>定义一个 Toy Dialect 上的 Operation</strong></p>
<p>有了 toy dialect，我们就可以开始注册该 Dialect 上的操作了。这将允许提供语义信息给剩余系统调用。以 <code>toy.constant</code> 操作的创建过程为例：</p>
<div class="highlight"><pre><span></span><code><span class="o">%</span><span class="mi">4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;toy.constant&quot;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dense</span><span class="o">&lt;</span><span class="mf">1.0</span><span class="o">&gt;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;</span><span class="mi">2</span><span class="n">x3xf64</span><span class="o">&gt;</span><span class="p">}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;</span><span class="mi">2</span><span class="n">x3xf64</span><span class="o">&gt;</span>
</code></pre></div>
<p><code>toy.constant</code> 操作没有参数，有一个名为value 的 <a href="https://mlir.llvm.org/docs/Dialects/Builtin/#denseintorfpelementsattr">dense elements</a>属性用来表示constant value，返回一个 <a href="https://mlir.llvm.org/docs/Dialects/Builtin/#rankedtensortype">RankedTensorType</a>。<code>ConstantOp</code> 继承自 CRTP <code>mlir::op</code>，该类还需要一些可选的 Traits(<code>mlir::OpTrait</code>) 来约束其行为。这些特征可以提供额外的accessors, verification等功能。</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">ConstantOp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">mlir</span><span class="o">::</span><span class="n">Op</span><span class="o">&lt;</span><span class="n">ConstantOp</span><span class="p">,</span>
<span class="w">                     </span><span class="c1">/// ConstantOp takes no inputs.</span>
<span class="w">                     </span><span class="n">mlir</span><span class="o">::</span><span class="n">OpTrait</span><span class="o">::</span><span class="n">ZeroOperands</span><span class="p">,</span>
<span class="w">                     </span><span class="c1">/// ConstantOp returns a single result.</span>
<span class="w">                     </span><span class="n">mlir</span><span class="o">::</span><span class="n">OpTrait</span><span class="o">::</span><span class="n">OneResult</span><span class="p">,</span>
<span class="w">                     </span><span class="c1">/// result of getType is `Type`.</span>
<span class="w">                     </span><span class="n">mlir</span><span class="o">::</span><span class="n">OpTrait</span><span class="o">::</span><span class="n">OneTypedResult</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">Impl</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>

<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="c1">/// Inherit the constructors from the base Op class.</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">Op</span><span class="o">::</span><span class="n">Op</span><span class="p">;</span>

<span class="w">  </span><span class="c1">/// 为这个 operation 提供一个 unique name</span>
<span class="w">  </span><span class="c1">/// MLIR 使用这个名字在全局注册该 Operation</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">StringRef</span><span class="w"> </span><span class="nf">getOperationName</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;toy.constant&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="c1">/// 返回 constant value by fetching it from the attribute.</span>
<span class="w">  </span><span class="n">mlir</span><span class="o">::</span><span class="n">DenseElementsAttr</span><span class="w"> </span><span class="nf">getValue</span><span class="p">();</span>

<span class="w">  </span><span class="c1">/// Operations 除了 traits 还可提供额外的 verification；</span>
<span class="w">  </span><span class="c1">/// 这里我们将确保 specific invariants of the constant</span>
<span class="w">  </span><span class="c1">/// operation are upheld. 例如， 返回类型必须是 TensorType.</span>
<span class="w">  </span><span class="n">LogicalResult</span><span class="w"> </span><span class="nf">verify</span><span class="p">();</span>

<span class="w">  </span><span class="c1">/// 提供从input values 构建该 operation 的接口</span>
<span class="w">  </span><span class="c1">/// builder 将会使用这个接口，从而能够简单地生成该 operation 实例:</span>
<span class="w">  </span><span class="c1">///   ``mlir::OpBuilder::create&lt;ConstantOp&gt;(...)``</span>
<span class="w">  </span><span class="c1">/// This method populates the given `state` that MLIR uses to create</span>
<span class="w">  </span><span class="c1">/// operations. This state is a collection of all of the discrete elements</span>
<span class="w">  </span><span class="c1">/// that an operation may contain.</span>
<span class="w">  </span><span class="c1">/// Build a constant with the given return type and `value` attribute.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">OpBuilder</span><span class="w"> </span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="n">mlir</span><span class="o">::</span><span class="n">OperationState</span><span class="w"> </span><span class="o">&amp;</span><span class="n">state</span><span class="p">,</span>
<span class="w">                    </span><span class="n">mlir</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">mlir</span><span class="o">::</span><span class="n">DenseElementsAttr</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
<span class="w">  </span><span class="c1">/// Build a constant and reuse the type from the given &#39;value&#39;.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">OpBuilder</span><span class="w"> </span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="n">mlir</span><span class="o">::</span><span class="n">OperationState</span><span class="w"> </span><span class="o">&amp;</span><span class="n">state</span><span class="p">,</span>
<span class="w">                    </span><span class="n">mlir</span><span class="o">::</span><span class="n">DenseElementsAttr</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
<span class="w">  </span><span class="c1">/// Build a constant 广播 given &#39;value&#39;.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">OpBuilder</span><span class="w"> </span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="n">mlir</span><span class="o">::</span><span class="n">OperationState</span><span class="w"> </span><span class="o">&amp;</span><span class="n">state</span><span class="p">,</span>
<span class="w">                    </span><span class="kt">double</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>
<p>并且我们在Toy Dialect构造函数中注册此操作：</p>
<div class="highlight"><pre><span></span><code><span class="n">ToyDialect</span><span class="o">::</span><span class="n">ToyDialect</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="w">   </span><span class="o">:</span><span class="w"> </span><span class="n">mlir</span><span class="o">::</span><span class="n">Dialect</span><span class="p">(</span><span class="n">getDialectNamespace</span><span class="p">(),</span><span class="w"> </span><span class="n">ctx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">addOperations</span><span class="o">&lt;</span><span class="n">ConstantOp</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
</blockquote>
<p>不过在这里我们也可以看到，为了适配各种接口，定义一个 <code>ConstantOp</code> 已经十分复杂了。 MLIR 为了解决这种复杂性， 提供了一个基于 TableGen 的 Operation Definition Specification (ODS) Framework， 用户通过ODS 声明 dialect 及其 Operations， MLIR 框架通过<code>mir-tblgen</code> 工具将该声明式语言自动转化为C++ 代码， 简化了用户自定义 dialect 的流程。 </p>
<p>这种方式是 MLIR 推荐的定义 Dialect 的方式， 在 Toy 语言中我们的 toy Dialect，也是通过这种方法来定义的。具体的文件在 <code>mlir/examples/toy/Ch2/include/toy/Ops.td</code> ， </p>
<div class="highlight"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">Toy_Dialect</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Dialect</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">let</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;toy&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">let</span><span class="w"> </span><span class="n">cppNamespace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;::mlir::toy&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">let</span><span class="w"> </span><span class="n">emitAccessorPrefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kEmitAccessorPrefix_Prefixed</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Inherits from the base `Op` class in `OpBase.td`</span>
<span class="c1">// And provides:</span>
<span class="c1">//   * Toy operation 的 parent dialect(即 toy dialect).</span>
<span class="c1">//   * Toy operation 的 mnemonic(助记词)， or the name without the dialect prefix.</span>
<span class="c1">//   * A list of traits for the operation.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Toy_Op</span><span class="o">&lt;</span><span class="n">string</span><span class="w"> </span><span class="n">mnemonic</span><span class="p">,</span><span class="w"> </span><span class="n">list</span><span class="o">&lt;</span><span class="n">Trait</span><span class="o">&gt;</span><span class="w"> </span><span class="n">traits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="o">&gt;</span><span class="w"> </span><span class="o">:</span>
<span class="w">    </span><span class="n">Op</span><span class="o">&lt;</span><span class="n">Toy_Dialect</span><span class="p">,</span><span class="w"> </span><span class="n">mnemonic</span><span class="p">,</span><span class="w"> </span><span class="n">traits</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
<p>其中 <code>ConstantOp</code> 的定义如下：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// ConstantOp(具体的 Operation) 继承 &#39;Toy_Op&#39;.</span>
<span class="c1">// 这里为 constant operation 提供了一个助记词 和一个 traits 列表.</span>
<span class="c1">// Constant operation 有 trait &#39;NoSideEffect&#39; 因为它是 pure operation, so that may be removed if dead.</span>
<span class="n">def</span><span class="w"> </span><span class="n">ConstantOp</span><span class="w"> </span>: <span class="nc">Toy_Op</span><span class="o">&lt;</span><span class="s">&quot;constant&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">NoSideEffect</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// summary and description. 可被用于自动生成文档</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">summary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;constant&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">description</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[{</span>
<span class="w">    </span><span class="n">Constant</span><span class="w"> </span><span class="n">operation</span><span class="w"> </span><span class="n">turns</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">literal</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">SSA</span><span class="w"> </span><span class="n">value</span><span class="p">.</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">attached</span>
<span class="w">    </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">operation</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">attribute</span><span class="p">.</span><span class="w"> </span><span class="n">For</span><span class="w"> </span><span class="n">example</span>:

    <span class="err">```</span><span class="n">mlir</span>
<span class="w">      </span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">toy</span><span class="p">.</span><span class="n">constant</span><span class="w"> </span><span class="n">dense</span><span class="o">&lt;</span><span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mf">4.0</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0</span><span class="p">,</span><span class="w"> </span><span class="mf">6.0</span><span class="p">]]</span><span class="o">&gt;</span>
<span class="w">                        </span>: <span class="nc">tensor</span><span class="o">&lt;</span><span class="mi">2</span><span class="n">x3xf64</span><span class="o">&gt;</span>
<span class="w">    </span><span class="err">```</span>
<span class="w">  </span><span class="p">}];</span>

<span class="w">  </span><span class="c1">// The constant operation 接收一个属性作为唯一的输入</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">arguments</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ins</span><span class="w"> </span><span class="n">F64ElementsAttr</span>:<span class="cp">$value</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// The constant operation 返回一个 TensorType 类型的值</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">outs</span><span class="w"> </span><span class="n">F64Tensor</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Indicate that the operation has a custom parser and printer method.</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">hasCustomAssemblyFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Add custom build methods for the constant operation. These method populates</span>
<span class="w">  </span><span class="c1">// the `state` that MLIR uses to create operations, i.e. these are used when</span>
<span class="w">  </span><span class="c1">// using `builder.create&lt;ConstantOp&gt;(...)`.</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">builders</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="c1">// Build a constant with a given constant tensor value.</span>
<span class="w">    </span><span class="n">OpBuilder</span><span class="o">&lt;</span><span class="p">(</span><span class="n">ins</span><span class="w"> </span><span class="s">&quot;DenseElementsAttr&quot;</span>:<span class="cp">$value</span><span class="p">),</span><span class="w"> </span><span class="p">[{</span>
<span class="w">      </span><span class="n">build</span><span class="p">(</span><span class="cp">$_builder</span><span class="p">,</span><span class="w"> </span><span class="cp">$_state</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">.</span><span class="n">getType</span><span class="p">(),</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
<span class="w">    </span><span class="p">}]</span><span class="o">&gt;</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// Build a constant with a given constant floating-point value.</span>
<span class="w">    </span><span class="n">OpBuilder</span><span class="o">&lt;</span><span class="p">(</span><span class="n">ins</span><span class="w"> </span><span class="s">&quot;double&quot;</span>:<span class="cp">$value</span><span class="p">)</span><span class="o">&gt;</span>
<span class="w">  </span><span class="p">];</span>

<span class="w">  </span><span class="c1">// https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/#verifying-operation-semantics</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">hasVerifier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>可以注意到这里 与上面的 C++ 代码相比缺少了 <code>ZeroOperands</code> and <code>OneResult</code> traits;</p>
<p>接下来我们使用 <code>mlir-tblgen</code> 工具自动将 <code>.td</code> 描述文件转成 C++ 代码：</p>
<ol>
<li>
<p><code>mlir-tblgen -gen-dialect-decls ../mlir/example/toy/Ch2/include/toy/Ops.td -I ../mlir/include</code></p>
<p>生成了<code>ToyDialect</code> 的c++代码定义：</p>
<div class="highlight"><pre><span></span><code><span class="cm">/*===- TableGen&#39;erated file -------------------------------------*- C++ -*-===*\</span>
<span class="cm">|*                                                                            *|</span>
<span class="cm">|* Dialect Declarations                                                       *|</span>
<span class="cm">|*                                                                            *|</span>
<span class="cm">|* Automatically generated file, do not edit!                                 *|</span>
<span class="cm">|*                                                                            *|</span>
<span class="cm">\*===----------------------------------------------------------------------===*/</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">mlir</span><span class="w"> </span><span class="p">{</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">toy</span><span class="w"> </span><span class="p">{</span>

<span class="k">class</span><span class="w"> </span><span class="nc">ToyDialect</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="o">::</span><span class="n">mlir</span><span class="o">::</span><span class="n">Dialect</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">explicit</span><span class="w"> </span><span class="n">ToyDialect</span><span class="p">(</span><span class="o">::</span><span class="n">mlir</span><span class="o">::</span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">);</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">initialize</span><span class="p">();</span>
<span class="w">  </span><span class="k">friend</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="o">::</span><span class="n">mlir</span><span class="o">::</span><span class="n">MLIRContext</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="o">~</span><span class="n">ToyDialect</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="o">::</span><span class="n">llvm</span><span class="o">::</span><span class="n">StringLiteral</span><span class="w"> </span><span class="nf">getDialectNamespace</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">::</span><span class="n">llvm</span><span class="o">::</span><span class="n">StringLiteral</span><span class="p">(</span><span class="s">&quot;toy&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace toy</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace mlir</span>
<span class="n">MLIR_DECLARE_EXPLICIT_TYPE_ID</span><span class="p">(</span><span class="o">::</span><span class="n">mlir</span><span class="o">::</span><span class="n">toy</span><span class="o">::</span><span class="n">ToyDialect</span><span class="p">)</span>
</code></pre></div>
<p>这些代码在 <code>Dialect.cpp</code> 中 被包含进去: <code>#include "toy/Dialect.cpp.inc"</code></p>
</li>
<li>
<p><code>mlir-tblgen -gen-op-defs ../mlir/example/toy/Ch2/include/toy/Ops.td -I ../mlir/include</code></p>
<p>类似，生成 Operations 的定义， 以 <code>ConstantOp</code>为例， 生成的代码在 <code>toy/Ops.cpp.inc</code> 和 <code>toy/Ops/h/inc</code> 中，太长不放在这里</p>
</li>
</ol>
<h2 id="3-chapter-3-high-level">3. Chapter 3: High-level 分析和转换</h2>
<p>MLIR 中使用 表达式匹配 和 重写 来完成 MLIR 分析/转换。这个教程中分别介绍使用 C++ 模式匹配和重写以及基于 <a href="https://mlir.llvm.org/docs/DeclarativeRewrites/">DRR 框架</a> 来定义重写规则，然后使用 ODS 框架来自动生成代码。</p>
<p>这里以 toy 语言中的一个连续两次转置的程序为例：</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">transpose_transpose</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<p>不做转换的情况下生成的 toy dialect 如下：</p>
<div class="highlight"><pre><span></span><code><span class="kd">func</span><span class="w"> </span><span class="err">@</span><span class="nx">transpose_transpose</span><span class="p">(</span><span class="o">%</span><span class="nx">arg0</span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;)</span><span class="w"> </span><span class="o">-</span><span class="p">&gt;</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">toy</span><span class="p">.</span><span class="nx">transpose</span><span class="p">(</span><span class="o">%</span><span class="nx">arg0</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;)</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;</span>
<span class="w">  </span><span class="o">%</span><span class="mi">1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">toy</span><span class="p">.</span><span class="nx">transpose</span><span class="p">(</span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;)</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;</span>
<span class="w">  </span><span class="nx">toy</span><span class="p">.</span><span class="k">return</span><span class="w"> </span><span class="o">%</span><span class="mi">1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;</span>
<span class="p">}</span>
</code></pre></div>
<p>如果将这个程序使用 C++ 写， 大概长这个样子：</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">sink</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">double_transpose</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">M</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">M</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">M</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">       </span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">M</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">       </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">sink</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>这个程序至少对于现在的 clang 而言， 无法将两次连续的转置消除。我们接下来看一下如何利用 MLIR 中的 模式匹配和重写机制实现 IR 的转换</p>
<h3 id="31-c-pass">3.1. 使用 C++ 写 pass</h3>
<p>可以直接写 C++ 来重写 IR，我们可以通过实现 <code>RewritePattern</code> 插入 MLIR Canonicalizer pass：</p>
<div class="highlight"><pre><span></span><code><span class="c1">/// 折叠 `transpose(transpose(x))` -&gt; `x`</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">SimplifyRedundantTranspose</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">mlir</span><span class="o">::</span><span class="n">OpRewritePattern</span><span class="o">&lt;</span><span class="n">TransposeOp</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">/// We register this pattern to match every toy.transpose in the IR.</span>
<span class="w">  </span><span class="c1">/// The &quot;benefit&quot; is used by the framework to order the patterns and process</span>
<span class="w">  </span><span class="c1">/// them in order of profitability.</span>
<span class="w">  </span><span class="n">SimplifyRedundantTranspose</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">OpRewritePattern</span><span class="o">&lt;</span><span class="n">TransposeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="cm">/*benefit=*/</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="c1">/// 这个方法尝试匹配固定的模式(即两个连续的转置)，并进行重写. </span>
<span class="w">  </span><span class="n">matchAndRewrite</span><span class="p">(</span><span class="n">TransposeOp</span><span class="w"> </span><span class="n">op</span><span class="p">,</span>
<span class="w">                  </span><span class="n">mlir</span><span class="o">::</span><span class="n">PatternRewriter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rewriter</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Look through the input of the current transpose.</span>
<span class="w">    </span><span class="n">mlir</span><span class="o">::</span><span class="n">Value</span><span class="w"> </span><span class="n">transposeInput</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op</span><span class="p">.</span><span class="n">getOperand</span><span class="p">();</span>
<span class="w">    </span><span class="n">TransposeOp</span><span class="w"> </span><span class="n">transposeInputOp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transposeInput</span><span class="p">.</span><span class="n">getDefiningOp</span><span class="o">&lt;</span><span class="n">TransposeOp</span><span class="o">&gt;</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Input defined by another transpose? If not, no match.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">transposeInputOp</span><span class="p">)</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">failure</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Otherwise, we have a redundant transpose. Use the rewriter.</span>
<span class="w">    </span><span class="n">rewriter</span><span class="p">.</span><span class="n">replaceOp</span><span class="p">(</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">transposeInputOp</span><span class="p">.</span><span class="n">getOperand</span><span class="p">()});</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">success</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>上述代码位于 <code>examples/toy/Ch3/mlir/ToyCombine.cpp</code>， 除了重写规则之外， 还需要将该规则添加到 规范化框架 (Canonicalization Framework) :</p>
<div class="highlight"><pre><span></span><code><span class="c1">/// 将我们的 SimplifyRedundantTranspose patterns 加入到 &quot;canonicalization&quot; 重写集合中</span>
<span class="c1">/// 从而执行 Canonicalize pass 时，会执行到这里</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">TransposeOp::getCanonicalizationPatterns</span><span class="p">(</span><span class="n">RewritePatternSet</span><span class="w"> </span><span class="o">&amp;</span><span class="n">results</span><span class="p">,</span>
<span class="w">                                              </span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">results</span><span class="p">.</span><span class="n">add</span><span class="o">&lt;</span><span class="n">SimplifyRedundantTranspose</span><span class="o">&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>将表达式重写规则添加到了规范化框架后，我们还需要修改一下定义 <code>TransposeOp</code> 的 <code>.td</code> 文件，启用规范化框架(添加 <code>let hasCanonicalizer=1</code>)，同时给 <code>TransposeOp</code> 的定义添加一个 <code>NoSideEffect</code> 的 trait， 现在 <code>Transpose</code> 操作的定义如下：</p>
<div class="highlight"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">TransposeOp</span><span class="w"> </span>: <span class="nc">Toy_Op</span><span class="o">&lt;</span><span class="s">&quot;transpose&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">NoSideEffect</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">summary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;transpose operation&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">arguments</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ins</span><span class="w"> </span><span class="n">F64Tensor</span>:<span class="cp">$input</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">outs</span><span class="w"> </span><span class="n">F64Tensor</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">assemblyFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[{</span>
<span class="w">    </span><span class="err">`</span><span class="p">(</span><span class="err">`</span><span class="w"> </span><span class="cp">$input</span><span class="w"> </span><span class="err">`</span>:<span class="err">`</span><span class="w"> </span><span class="k">type</span><span class="p">(</span><span class="cp">$input</span><span class="p">)</span><span class="w"> </span><span class="err">`</span><span class="p">)</span><span class="err">`</span><span class="w"> </span><span class="n">attr</span><span class="o">-</span><span class="n">dict</span><span class="w"> </span><span class="err">`</span><span class="n">to</span><span class="err">`</span><span class="w"> </span><span class="k">type</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
<span class="w">  </span><span class="p">}];</span>

<span class="w">  </span><span class="c1">// Enable registering canonicalization patterns with this operation.</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">hasCanonicalizer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">builders</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="n">OpBuilder</span><span class="o">&lt;</span><span class="p">(</span><span class="n">ins</span><span class="w"> </span><span class="s">&quot;Value&quot;</span>:<span class="cp">$input</span><span class="p">)</span><span class="o">&gt;</span>
<span class="w">  </span><span class="p">];</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">hasVerifier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>我们还需要更新 <code>toyc.cpp</code>， 以添加优化 pass。在 MLIR 中，优化以类似于 LLVM 的方式通过 PassManager 运行：</p>
<div class="highlight"><pre><span></span><code><span class="n">mlir</span><span class="o">::</span><span class="n">PassManager</span><span class="w"> </span><span class="nf">pm</span><span class="p">(</span><span class="k">module</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">());</span>
<span class="n">pm</span><span class="p">.</span><span class="n">addNestedPass</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">toy</span><span class="o">::</span><span class="n">FuncOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">createCanonicalizerPass</span><span class="p">());</span>
</code></pre></div>
<p>然后运行 <code>./bin/toyc-ch3 ../mlir/test/Examples/Toy/Ch3/transpose_transpose.toy -emit=mlir -opt</code> 得到</p>
<div class="highlight"><pre><span></span><code><span class="nx">module</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 注意对比这里优化后 与 之前未优化</span>
<span class="w">  </span><span class="nx">toy</span><span class="p">.</span><span class="kd">func</span><span class="w"> </span><span class="err">@</span><span class="nx">transpose_transpose</span><span class="p">(</span><span class="o">%</span><span class="nx">arg0</span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;)</span><span class="w"> </span><span class="o">-</span><span class="p">&gt;</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">toy</span><span class="p">.</span><span class="k">return</span><span class="w"> </span><span class="o">%</span><span class="nx">arg0</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nx">toy</span><span class="p">.</span><span class="kd">func</span><span class="w"> </span><span class="err">@</span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">toy</span><span class="p">.</span><span class="nx">constant</span><span class="w"> </span><span class="nx">dense</span><span class="p">&lt;[[</span><span class="mf">1.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">2.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">3.000000e+00</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mf">4.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">5.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">6.000000e+00</span><span class="p">]]&gt;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="o">%</span><span class="mi">1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">toy</span><span class="p">.</span><span class="nx">generic_call</span><span class="w"> </span><span class="err">@</span><span class="nx">transpose_transpose</span><span class="p">(</span><span class="o">%</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;)</span><span class="w"> </span><span class="o">-</span><span class="p">&gt;</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">toy</span><span class="p">.</span><span class="nx">print</span><span class="w"> </span><span class="o">%</span><span class="mi">1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">toy</span><span class="p">.</span><span class="k">return</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>这里需要注意， 如果我们不修改 <code>.td</code> 中 <code>TransposeOp</code> 的 trait（添加一个 <code>NoSideEffect</code>）， 则会出现以下结果：</p>
<div class="highlight"><pre><span></span><code><span class="nx">toy</span><span class="p">.</span><span class="kd">func</span><span class="w"> </span><span class="err">@</span><span class="nx">transpose_transpose</span><span class="p">(</span><span class="o">%</span><span class="nx">arg0</span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;)</span><span class="w"> </span><span class="o">-</span><span class="p">&gt;</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">toy</span><span class="p">.</span><span class="nx">transpose</span><span class="p">(</span><span class="o">%</span><span class="nx">arg0</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;)</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;</span>
<span class="w">  </span><span class="nx">toy</span><span class="p">.</span><span class="k">return</span><span class="w"> </span><span class="o">%</span><span class="nx">arg0</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;</span>
<span class="p">}</span>
</code></pre></div>
<p>这是因为， 我们的模式用函数输入替换了最后一个变换，并留下了现在死掉的转置输入。 Canonicalizer 知道清理死操作；然而，MLIR 保守地假设操作可能有副作用。而在为 <code>TransposeOp</code> 添加一个 <code>NoSideEffect</code> 可以解决这个问题。 这个 trait 在 <code>include/mlir/Interfaces/SideEffectInterfaces.td</code> 中定义 TODO: 之后可以研究一下 在 MLIR 中怎么定义 并使用 trait</p>
<h3 id="32-drr-pass">3.2. 使用 DRR 写 pass</h3>
<p>MLIR 还提供了一种基于 DDR 规则的方式来自动生成 模式匹配 和 重写函数，代码生成的部分仍然基于 ODS 框架实现。Declarative, rule-based pattern-match and rewrite (DRR) 它是一种基于 DAG 的声明式重写器，提供基于 tablegen 的模式匹配和重写规则的句法：</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Pattern</span><span class="o">&lt;</span>
<span class="w">    </span><span class="n">dag</span><span class="w"> </span><span class="n">sourcePattern</span><span class="p">,</span><span class="w"> </span><span class="n">list</span><span class="o">&lt;</span><span class="n">dag</span><span class="o">&gt;</span><span class="w"> </span><span class="n">resultPatterns</span><span class="p">,</span>
<span class="w">    </span><span class="n">list</span><span class="o">&lt;</span><span class="n">dag</span><span class="o">&gt;</span><span class="w"> </span><span class="n">additionalConstraints</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[],</span>
<span class="w">    </span><span class="n">dag</span><span class="w"> </span><span class="n">benefitsAdded</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">addBenefit</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
<p>接下来以消除 MLIR 表达式中冗余的张量 reshape 操作为例:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">var</span> <span class="n">a</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
  <span class="n">var</span> <span class="n">b</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">var</span> <span class="n">c</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>对应的 toy dialect 如下：</p>
<div class="highlight"><pre><span></span><code><span class="nx">module</span><span class="w">  </span><span class="p">{</span>
<span class="w">  </span><span class="kd">func</span><span class="w"> </span><span class="err">@</span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">toy</span><span class="p">.</span><span class="nx">constant</span><span class="w"> </span><span class="nx">dense</span><span class="p">&lt;[</span><span class="mf">1.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">2.000000e+00</span><span class="p">]&gt;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="o">%</span><span class="mi">1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">toy</span><span class="p">.</span><span class="nx">reshape</span><span class="p">(</span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">xf64</span><span class="p">&gt;)</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x1xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="o">%</span><span class="mi">2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">toy</span><span class="p">.</span><span class="nx">reshape</span><span class="p">(</span><span class="o">%</span><span class="mi">1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x1xf64</span><span class="p">&gt;)</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x1xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="o">%</span><span class="mi">3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">toy</span><span class="p">.</span><span class="nx">reshape</span><span class="p">(</span><span class="o">%</span><span class="mi">2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x1xf64</span><span class="p">&gt;)</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x1xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">toy</span><span class="p">.</span><span class="nx">print</span><span class="w"> </span><span class="o">%</span><span class="mi">3</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x1xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">toy</span><span class="p">.</span><span class="k">return</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>a，b，c 完全相同， 我们有机会在 dialect 中消除冗余的 <code>reshape</code> 。 下面我们要基于 DDR 框架来定义匹配和消除规则。</p>
<p>类似于 <code>SimplifyRedundantTranspose</code> 的针对 冗余 <code>reshape</code> 的优化可以使用 DRR 更简单地表示如下：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Reshape(Reshape(x)) -&gt; Reshape(x)</span>
<span class="n">def</span><span class="w"> </span><span class="n">ReshapeReshapeOptPattern</span><span class="w"> </span>: <span class="nc">Pat</span><span class="o">&lt;</span><span class="p">(</span><span class="n">ReshapeOp</span><span class="p">(</span><span class="n">ReshapeOp</span><span class="w"> </span><span class="cp">$arg</span><span class="p">)),</span>
<span class="w">                                   </span><span class="p">(</span><span class="n">ReshapeOp</span><span class="w"> </span><span class="cp">$arg</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
<p>当转换以参数和结果的某些属性为条件时，DRR 还提供了一种添加参数约束的方法。一个例子是当 reshape 的参数和结果的类型是一样的，说明这个 reshape 是无用的，直接返回输入参数即可， 即 <code>Reshape(x) = x</code></p>
<p><div class="highlight"><pre><span></span><code><span class="c1">// Reshape(x) = x, where input and output shapes are identical</span>
<span class="n">def</span><span class="w"> </span><span class="n">TypesAreIdentical</span><span class="w"> </span>: <span class="nc">Constraint</span><span class="o">&lt;</span><span class="n">CPred</span><span class="o">&lt;</span><span class="s">&quot;$0.getType() == $1.getType()&quot;</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="n">def</span><span class="w"> </span><span class="n">RedundantReshapeOptPattern</span><span class="w"> </span>: <span class="nc">Pat</span><span class="o">&lt;</span>
<span class="w">  </span><span class="p">(</span><span class="n">ReshapeOp</span>:<span class="cp">$res</span><span class="w"> </span><span class="cp">$arg</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="n">replaceWithValue</span><span class="w"> </span><span class="cp">$arg</span><span class="p">),</span>
<span class="w">  </span><span class="p">[(</span><span class="n">TypesAreIdentical</span><span class="w"> </span><span class="cp">$res</span><span class="p">,</span><span class="w"> </span><span class="cp">$arg</span><span class="p">)]</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
即当 <code>0.getType()</code> 与 <code>1.getType()</code> 相同时，使用操作数 <code>$arg</code> 代替。</p>
<p>同样需要将这个函数加入到</p>
<p>DRR代码位于 <code>mlir/examples/toy/Ch3/mlir/ToyCombine.td</code>， 生成的代码位于 <code>Ch3/ToyCombine.inc</code></p>
<p>执行 <code>./bin/toyc-ch3 ../mlir/test/Examples/Toy/Ch3/trivial_reshape.toy -emit=mlir -opt</code></p>
<p>得到结果如下：</p>
<div class="highlight"><pre><span></span><code><span class="nx">module</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">toy</span><span class="p">.</span><span class="kd">func</span><span class="w"> </span><span class="err">@</span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">toy</span><span class="p">.</span><span class="nx">constant</span><span class="w"> </span><span class="nx">dense</span><span class="p">&lt;[[</span><span class="mf">1.000000e+00</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mf">2.000000e+00</span><span class="p">]]&gt;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x1xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">toy</span><span class="p">.</span><span class="nx">print</span><span class="w"> </span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x1xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">toy</span><span class="p">.</span><span class="k">return</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="4-chapter-4-interfaces-transformation">4. Chapter 4: 使用 Interfaces 泛化 Transformation</h2>
<p>上面实现的重写规则有一个明显的问题：我们为 Toy Dialect 实现的 Pass 在其它的 Dialect 中没办法重用，因为是针对 Toy dialect 一些 Operation 的特化操作，如果为每种 Dialect 实现每种转化会导致大量重复代码。所以，这一节看如何在 MLIR 中 利用 Interfaces 实现泛化。</p>
<p>首先是 <code>mlir/test/Examples/Toy/Ch4/codegen.toy</code> 中的例子</p>
<div class="highlight"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">multiply_transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">transpose</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">def</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">var</span><span class="w"> </span><span class="n">a</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]];</span>
<span class="w">  </span><span class="n">var</span><span class="w"> </span><span class="n">b</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">];</span>
<span class="w">  </span><span class="n">var</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">multiply_transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w">  </span><span class="n">var</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">multiply_transpose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
<span class="w">  </span><span class="n">print</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>其生成的 Toy Dialect：</p>
<div class="highlight"><pre><span></span><code><span class="nx">module</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">toy</span><span class="p">.</span><span class="kd">func</span><span class="w"> </span><span class="nx">private</span><span class="w"> </span><span class="err">@</span><span class="nx">multiply_transpose</span><span class="p">(</span><span class="o">%</span><span class="nx">arg0</span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;,</span><span class="w"> </span><span class="o">%</span><span class="nx">arg1</span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;)</span><span class="w"> </span><span class="o">-</span><span class="p">&gt;</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">toy</span><span class="p">.</span><span class="nx">transpose</span><span class="p">(</span><span class="o">%</span><span class="nx">arg0</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;)</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="o">%</span><span class="mi">1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">toy</span><span class="p">.</span><span class="nx">transpose</span><span class="p">(</span><span class="o">%</span><span class="nx">arg1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;)</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="o">%</span><span class="mi">2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">toy</span><span class="p">.</span><span class="nx">mul</span><span class="w"> </span><span class="o">%</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">toy</span><span class="p">.</span><span class="k">return</span><span class="w"> </span><span class="o">%</span><span class="mi">2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nx">toy</span><span class="p">.</span><span class="kd">func</span><span class="w"> </span><span class="err">@</span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">toy</span><span class="p">.</span><span class="nx">constant</span><span class="w"> </span><span class="nx">dense</span><span class="p">&lt;[[</span><span class="mf">1.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">2.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">3.000000e+00</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mf">4.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">5.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">6.000000e+00</span><span class="p">]]&gt;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="o">%</span><span class="mi">1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">toy</span><span class="p">.</span><span class="nx">reshape</span><span class="p">(</span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;)</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="o">%</span><span class="mi">2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">toy</span><span class="p">.</span><span class="nx">constant</span><span class="w"> </span><span class="nx">dense</span><span class="p">&lt;[</span><span class="mf">1.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">2.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">3.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">4.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">5.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">6.000000e+00</span><span class="p">]&gt;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">6</span><span class="nx">xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="o">%</span><span class="mi">3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">toy</span><span class="p">.</span><span class="nx">reshape</span><span class="p">(</span><span class="o">%</span><span class="mi">2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">6</span><span class="nx">xf64</span><span class="p">&gt;)</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="o">%</span><span class="mi">4</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">toy</span><span class="p">.</span><span class="nx">generic_call</span><span class="w"> </span><span class="err">@</span><span class="nx">multiply_transpose</span><span class="p">(</span><span class="o">%</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;,</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;)</span><span class="w"> </span><span class="o">-</span><span class="p">&gt;</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="o">%</span><span class="mi">5</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">toy</span><span class="p">.</span><span class="nx">generic_call</span><span class="w"> </span><span class="err">@</span><span class="nx">multiply_transpose</span><span class="p">(</span><span class="o">%</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;,</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;)</span><span class="w"> </span><span class="o">-</span><span class="p">&gt;</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">toy</span><span class="p">.</span><span class="nx">print</span><span class="w"> </span><span class="o">%</span><span class="mi">5</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">toy</span><span class="p">.</span><span class="k">return</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>💡注意到这里 <code>multiply_transpose</code> 的签名输入输出类型 都是 <code>tensor&lt;*xf64&gt;</code> 即<strong>动态形状</strong>， 或者叫 generic tensor</p>
<p>在这一节的优化之后(<code>./bin/toyc-ch4 ../mlir/test/Examples/Toy/Ch4/codegen.toy -emit=mlir -opt</code>)， 生成的 IR 将会变为：</p>
<div class="highlight"><pre><span></span><code><span class="nx">module</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">toy</span><span class="p">.</span><span class="kd">func</span><span class="w"> </span><span class="err">@</span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">toy</span><span class="p">.</span><span class="nx">constant</span><span class="w"> </span><span class="nx">dense</span><span class="p">&lt;[[</span><span class="mf">1.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">2.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">3.000000e+00</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mf">4.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">5.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">6.000000e+00</span><span class="p">]]&gt;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="o">%</span><span class="mi">1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">toy</span><span class="p">.</span><span class="nx">transpose</span><span class="p">(</span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;)</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">3</span><span class="nx">x2xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="o">%</span><span class="mi">2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">toy</span><span class="p">.</span><span class="nx">mul</span><span class="w"> </span><span class="o">%</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">3</span><span class="nx">x2xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">toy</span><span class="p">.</span><span class="nx">print</span><span class="w"> </span><span class="o">%</span><span class="mi">2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">3</span><span class="nx">x2xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">toy</span><span class="p">.</span><span class="k">return</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>💡先是利用到了上一节中的优化消除掉了冗余的 <code>reshape</code>；并且此时 <code>multiply_transpose</code> 被内联（原定义被删除）； 最重要的是<strong>所有的 tensor 形状都变成了 static， IR 中 不再具有动态形状</strong>； 并且 <code>%4</code> and <code>%5</code> 相同， 因此只被计算了一次；</p>
<p>Toy IR 目前操作 generic tensors， 这意味着除了使用常量初始化的 tensor， 我们不知道其它 tensor 的形状。这使 优化 和 代码生成 变得复杂。我们可以通过在 IR 中传播编译时已知的静态形状 来缓解这个问题。形状传播的难题在于如何处理 user-defined 函数调用参数和返回值都没有给出形状信息（即上面例子中的 <code>multiply_transpose</code>）：每个调用点都可以推断出不同的形状。一种可能是根据参数类型<strong>执行符号推理</strong>，但随着引入更多控制流，符号推理将很难泛化。另一种方法是函数特化，其中每个具有新参数形状的调用点都内联被调用函数并对其进行特化。我们对 Toy 采取的方法是内联所有函数调用，然后<strong>执行过程内形状传播</strong>。</p>
<p>我们可以编写专为 Toy Dialect 设计的内联算法，但这可能会变得相当复杂。撇开成本建模不谈，从头开始写固定模式的代码就已经很复杂了。MLIR 提供了 <strong>Dialect 可以 接入 的通用内联算法</strong>。在 Toy 中，我们需要做的就是为内联器提供 <a href="https://mlir.llvm.org/docs/Interfaces/">Interfaces</a>。</p>
<ol>
<li>
<p>第一步是在 Toy Dialect 中定义对内联操作的约束。此信息通过 <a href="https://mlir.llvm.org/docs/Interfaces/#dialect-interfaces">dialect interface</a> 提供。 dialect interface 本质上是包含一组 virtual hooks 的类，方言通过重写这些方法提供具体实现。在这个内联例子中， 我们用到的 Interface 是 <code>DialectInlinerInterface</code></p>
<div class="highlight"><pre><span></span><code><span class="c1">/// 这个类定义了用于 Toy Dialect 执行 inline 操作的接口</span>
<span class="c1">/// 这里的实现做了简化，并且只重写了必要的方法</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ToyInlinerInterface</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">DialectInlinerInterface</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">DialectInlinerInterface</span><span class="o">::</span><span class="n">DialectInlinerInterface</span><span class="p">;</span>

<span class="w">  </span><span class="c1">/// 在我们的例子中 simply return true, 因为 Toy `Call` operation 总是可内联的</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">isLegalToInline</span><span class="p">(</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">call</span><span class="p">,</span><span class="w"> </span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">callable</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">wouldBeCloned</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">final</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">/// 在我们的例子中 simply return true, 因为 Toy operation 总是可内联的</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">isLegalToInline</span><span class="p">(</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">Region</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">IRMapping</span><span class="w"> </span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">final</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">/// 同上</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">isLegalToInline</span><span class="p">(</span><span class="n">Region</span><span class="w"> </span><span class="o">*</span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="n">Region</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">wouldBeCloned</span><span class="p">,</span><span class="w"> </span><span class="n">IRMapping</span><span class="w"> </span><span class="o">&amp;</span><span class="n">valueMapping</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">final</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">/// 当一个 terminator operation 被 inline 后执行此 hook， 保证控制流的正确性（不会提前返回）</span>
<span class="w">  </span><span class="c1">/// Toy 中唯一的 terminator Operation是 `toy.return`</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">handleTerminator</span><span class="p">(</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">Value</span><span class="o">&gt;</span><span class="w"> </span><span class="n">valuesToRepl</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">final</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 处理 &quot;toy.return&quot;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">returnOp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cast</span><span class="o">&lt;</span><span class="n">ReturnOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 简单的将 return 语句替换成 return 语句的 operands</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">returnOp</span><span class="p">.</span><span class="n">getNumOperands</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">valuesToRepl</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">it</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">enumerate</span><span class="p">(</span><span class="n">returnOp</span><span class="p">.</span><span class="n">getOperands</span><span class="p">()))</span>
<span class="w">      </span><span class="n">valuesToRepl</span><span class="p">[</span><span class="n">it</span><span class="p">.</span><span class="n">index</span><span class="p">()].</span><span class="n">replaceAllUsesWith</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">value</span><span class="p">());</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>此外，内联器只会 删除 私有可见的未使用函数定义。因此还需要在 <code>mlirGen</code> 中设置函数（<code>main</code>除外）为 private</p>
<div class="highlight"><pre><span></span><code><span class="n">mlir</span><span class="o">::</span><span class="n">toy</span><span class="o">::</span><span class="n">FuncOp</span><span class="w"> </span><span class="nf">mlirGen</span><span class="p">(</span><span class="n">FunctionAST</span><span class="w"> </span><span class="o">&amp;</span><span class="n">funcAST</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">funcAST</span><span class="p">.</span><span class="n">getProto</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s">&quot;main&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="n">function</span><span class="p">.</span><span class="n">setPrivate</span><span class="p">();</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div>
</li>
<li>
<p>然后我们直接在 Toy Dialect 上注册我们的 Dialect interface；在文件 <code>mlir/examples/toy/Ch5/mlir/Dialect.cpp</code> 中:</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">ToyDialect::initialize</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">addOperations</span><span class="o">&lt;</span>
<span class="cp">#define GET_OP_LIST</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;toy/Ops.cpp.inc&quot;</span>
<span class="w">      </span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="n">addInterfaces</span><span class="o">&lt;</span><span class="n">ToyInlinerInterface</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>这里的 <code>addInterfaces&lt;ToyInlinerInterface&gt;()</code> 就是注册内联 Pass 的过程，其中<code>ToyInlinerInterface</code> 就是我们定义的表达式变形规则。</p>
</li>
<li>
<p>接下来，我们需要提供一种方法让内联器知道 <code>toy.generic_call</code> 代表一个调用， <code>toy.func</code> 代表一个函数。 MLIR 提供了 <a href="https://mlir.llvm.org/docs/Interfaces/#attributeoperationtype-interfaces">operation interface</a>， 可用于将 operation 标记为 <code>call-like</code> 或 <code>callable-like</code> (与 dialect interface 不同， operation interface 提供更细粒度的信息)， 这里为 GenericCallOp 添加 <code>CallOpInterface</code> ， 为 FuncOp <code>CallableOpInterface</code> </p>
<p>要添加此接口，我们只需将定义 include 到我们的 operation 描述文件 (<code>Ops.td</code>) 中：</p>
<div class="highlight"><pre><span></span><code><span class="n">include</span> <span class="s2">&quot;mlir/Interfaces/CallInterfaces.td&quot;</span>

<span class="o">...</span>

<span class="k">def</span> <span class="nf">FuncOp</span> <span class="p">:</span> <span class="n">Toy_Op</span><span class="o">&lt;</span><span class="s2">&quot;func&quot;</span><span class="p">,</span>
    <span class="p">[</span><span class="n">DeclareOpInterfaceMethods</span><span class="o">&lt;</span><span class="n">CallableOpInterface</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">GenericCallOp</span> <span class="p">:</span> <span class="n">Toy_Op</span><span class="o">&lt;</span><span class="s2">&quot;generic_call&quot;</span><span class="p">,</span>
    <span class="p">[</span><span class="n">DeclareOpInterfaceMethods</span><span class="o">&lt;</span><span class="n">CallOpInterface</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">}</span>
</code></pre></div>
</li>
<li>
<p>还需要在 Dialect 定义中添加 cast 操作并设置调用的接口。为什么需要添加 cast 操作呢？这是因为在函数调用时，输入张量的类型是确定的。但在函数定义的时候，输入张量的类型是 generic 的。即我们需要<code>tensor&lt;2x3xf64&gt; -&gt; tensor&lt;*xf64&gt;</code> 。下面在 <code>mlir/examples/toy/Ch5/include/toy/Ops.td</code> 中添加 cast 操作：</p>
<div class="highlight"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">CastOp</span><span class="w"> </span>: <span class="nc">Toy_Op</span><span class="o">&lt;</span><span class="s">&quot;cast&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="n">DeclareOpInterfaceMethods</span><span class="o">&lt;</span><span class="n">CastOpInterface</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="n">NoSideEffect</span><span class="p">,</span>
<span class="w">    </span><span class="n">SameOperandsAndResultShape</span>
<span class="w">  </span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">summary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;shape cast operation&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">description</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[{</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">}];</span>

<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">arguments</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ins</span><span class="w"> </span><span class="n">F64Tensor</span>:<span class="cp">$input</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">outs</span><span class="w"> </span><span class="n">F64Tensor</span>:<span class="cp">$output</span><span class="p">);</span>

<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">assemblyFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;$input attr-dict `:` type($input) `to` type($output)&quot;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>我们使用了 <code>DeclareOpInterfaceMethods</code> 在 <code>CallOpInterface</code> 的声明中声明所用的接口方法。 <code>DeclareOpInterfaceMethods</code> 这个 trait 说明程序会识别 cast 操作。</p>
<p>接下来还需要重写 cast op 的 <code>areCastCompatible</code> 方法（在 <code>mlir/examples/toy/Ch5/mlir/Dialect.cpp</code>中）：</p>
<p><div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="nf">CastOp::areCastCompatible</span><span class="p">(</span><span class="n">TypeRange</span><span class="w"> </span><span class="n">inputs</span><span class="p">,</span><span class="w"> </span><span class="n">TypeRange</span><span class="w"> </span><span class="n">outputs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">inputs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">outputs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// The inputs must be Tensors with the same element type.</span>
<span class="w">  </span><span class="n">TensorType</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inputs</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">TensorType</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="n">TensorType</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outputs</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">TensorType</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">input</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">output</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">getElementType</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">output</span><span class="p">.</span><span class="n">getElementType</span><span class="p">())</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// The shape is required to match if both types are ranked.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">!</span><span class="n">input</span><span class="p">.</span><span class="n">hasRank</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">output</span><span class="p">.</span><span class="n">hasRank</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">output</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
这个方法用来判断是否需要进行类型转换，如果 inputs 和 outputs 的类型是兼容返回真，否则需要进行类型转换（cast）返回假。</p>
<p>另外我们还需要重写 <code>ToyInlinerInterface</code> 上的 hook ， 即 <code>materializeCallConversion</code> 函数：</p>
<p><div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">ToyInlinerInterface</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">DialectInlinerInterface</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">....</span>
<span class="w">  </span><span class="c1">/// 尝试在函数调用的地方插入 cast 节点. 如果不能转换 返回 nullptr</span>
<span class="w">  </span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">materializeCallConversion</span><span class="p">(</span><span class="n">OpBuilder</span><span class="w"> </span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="n">input</span><span class="p">,</span>
<span class="w">                                      </span><span class="n">Type</span><span class="w"> </span><span class="n">resultType</span><span class="p">,</span>
<span class="w">                                      </span><span class="n">Location</span><span class="w"> </span><span class="n">conversionLoc</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">final</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">create</span><span class="o">&lt;</span><span class="n">CastOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">conversionLoc</span><span class="p">,</span><span class="w"> </span><span class="n">resultType</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
这个函数是内联 Pass 的入口。</p>
</li>
<li>
<p>将 Inline Pass 添加到优化 pipline 中，在 <code>mlir/examples/toy/Ch5/toyc.cpp</code> 中：</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">enableOpt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">mlir</span><span class="o">::</span><span class="n">PassManager</span><span class="w"> </span><span class="nf">pm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Apply any generic pass manager command line options and run the pipeline.</span>
<span class="w">    </span><span class="n">applyPassManagerCLOptions</span><span class="p">(</span><span class="n">pm</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 将所有的 call 插入 main 并且删除之</span>
<span class="w">    </span><span class="n">pm</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">createInlinerPass</span><span class="p">());</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre></div>
</li>
</ol>
<p>此时得到的 toy dialect 如下：</p>
<div class="highlight"><pre><span></span><code><span class="kd">func</span><span class="w"> </span><span class="err">@</span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;toy.constant&quot;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="nx">value</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">dense</span><span class="p">&lt;[[</span><span class="mf">1.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">2.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">3.000000e+00</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mf">4.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">5.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">6.000000e+00</span><span class="p">]]&gt;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;}</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="p">&gt;</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;</span>
<span class="w">  </span><span class="o">%</span><span class="mi">1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;toy.constant&quot;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="nx">value</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">dense</span><span class="p">&lt;[[</span><span class="mf">1.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">2.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">3.000000e+00</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mf">4.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">5.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">6.000000e+00</span><span class="p">]]&gt;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;}</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="p">&gt;</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;</span>
<span class="w">  </span><span class="o">%</span><span class="mi">2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;toy.cast&quot;</span><span class="p">(</span><span class="o">%</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;)</span><span class="w"> </span><span class="o">-</span><span class="p">&gt;</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;</span>
<span class="w">  </span><span class="o">%</span><span class="mi">3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;toy.cast&quot;</span><span class="p">(</span><span class="o">%</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="nx">tensor</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;)</span><span class="w"> </span><span class="o">-</span><span class="p">&gt;</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;</span>
<span class="w">  </span><span class="o">%</span><span class="mi">4</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;toy.transpose&quot;</span><span class="p">(</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;)</span><span class="w"> </span><span class="o">-</span><span class="p">&gt;</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;</span>
<span class="w">  </span><span class="o">%</span><span class="mi">5</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;toy.transpose&quot;</span><span class="p">(</span><span class="o">%</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;)</span><span class="w"> </span><span class="o">-</span><span class="p">&gt;</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;</span>
<span class="w">  </span><span class="o">%</span><span class="mi">6</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;toy.mul&quot;</span><span class="p">(</span><span class="o">%</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;,</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;)</span><span class="w"> </span><span class="o">-</span><span class="p">&gt;</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;</span>
<span class="w">  </span><span class="nx">toy</span><span class="p">.</span><span class="nx">print</span><span class="w"> </span><span class="o">%</span><span class="mi">6</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">tensor</span><span class="p">&lt;</span><span class="o">*</span><span class="nx">xf64</span><span class="p">&gt;</span>
<span class="w">  </span><span class="nx">toy</span><span class="p">.</span><span class="k">return</span>
<span class="p">}</span>
</code></pre></div>
<p>现在 MLIR 表达式只有一个主函数，之前的 <code>transpose</code> 函数被内联了，并且可以看到 <code>toy.cast</code> 实现的功能。</p>
<h3 id="42-pass">4.2. 形状传播 pass</h3>
<p>现在我们已经内联了所有函数，剩下的是一个包含静态和动态形状操作混合的主函数。我们现在可以编写一个简单的形状推理过程在单个函数内播形状。我们可以将其写成针对 Toy Dialect pass，然而经验法则告诉我们，最好尽可能通用地表达转换，以便将来可以扩展到其他方言。</p>
<p>与 Operation 类似，我们也可以使用 ODS 框架来定义 Operation Interfaces</p>
<ol>
<li>
<p>使用 ODS 框架定义 Shape 推断 Operation Interface， 代码在 <code>mlir/examples/toy/Ch5/include/toy/ShapeInferenceInterface.td</code></p>
<div class="highlight"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">ShapeInferenceOpInterface</span><span class="w"> </span>: <span class="nc">OpInterface</span><span class="o">&lt;</span><span class="s">&quot;ShapeInference&quot;</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">description</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[{</span>
<span class="w">    </span><span class="n">Interface</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">access</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">registered</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">infer</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">types</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">an</span>
<span class="w">    </span><span class="n">operation</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="n">during</span><span class="w"> </span><span class="k">type</span> <span class="nc">inference</span><span class="p">.</span>
<span class="w">  </span><span class="p">}];</span>

<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">methods</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="n">InterfaceMethod</span><span class="o">&lt;</span><span class="s">&quot;Infer and set the output shape for the current operation.&quot;</span><span class="p">,</span>
<span class="w">                    </span><span class="s">&quot;void&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;inferShapes&quot;</span><span class="o">&gt;</span>
<span class="w">  </span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div>
<p>其中的 <code>method</code> 表示需要为该接口提供的方法 ， 三个字段分别表示 desc， return type， method name
2. 将 定义的 <code>ShapeInferenceOpInterface</code> 添加到必要的 Toy Operation 定义中</p>
<p>这里我们给 <code>AddOp</code>, <code>MulOp</code>, <code>CastOp</code> 和 <code>TranposeOp</code> 加上 ShapeInferenceOpInterface：</p>
<div class="highlight"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">CastOp</span><span class="w"> </span>: <span class="nc">Toy_Op</span><span class="o">&lt;</span><span class="s">&quot;cast&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="n">DeclareOpInterfaceMethods</span><span class="o">&lt;</span><span class="n">CastOpInterface</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="c1">// 这里添加 ShapeInferenceOpInterface</span>
<span class="w">    </span><span class="n">DeclareOpInterfaceMethods</span><span class="o">&lt;</span><span class="n">ShapeInferenceOpInterface</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">NoSideEffect</span><span class="p">,</span>
<span class="w">    </span><span class="n">SameOperandsAndResultShape</span>
<span class="w">  </span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="o">..</span><span class="p">.}</span>
</code></pre></div>
<p>所有添加了 <code>ShapeInferenceOpInterface</code> 的 Op 都需要实现接口<code>method</code>字段中定义的的 <code>inferShapes</code> 方法：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// cast op 的形状推断函数</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">CastOp::inferShapes</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">getResult</span><span class="p">().</span><span class="n">setType</span><span class="p">(</span><span class="n">getOperand</span><span class="p">().</span><span class="n">getType</span><span class="p">());</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// transpose op 的 形状推断函数</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">TransposeOp::inferShapes</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">arrayTy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getOperand</span><span class="p">().</span><span class="n">getType</span><span class="p">().</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">RankedTensorType</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dims</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">arrayTy</span><span class="p">.</span><span class="n">getShape</span><span class="p">()));</span>
<span class="w">  </span><span class="n">getResult</span><span class="p">().</span><span class="n">setType</span><span class="p">(</span><span class="n">RankedTensorType</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span><span class="w"> </span><span class="n">arrayTy</span><span class="p">.</span><span class="n">getElementType</span><span class="p">()));</span>
<span class="p">}</span>
</code></pre></div>
</li>
<li>
<p>实现形状推导（即形状传播） Pass</p>
<p><code>ShapeInferencePass</code> 将对函数进行操作：它将在每个函数上独立运行。 MLIR 还支持在任何 单独的 Operation 上运行的通用 <code>OperationPass</code>，但这里我们的 module仅包含函数，因此无需泛化到所有操作。</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">ShapeInferencePass</span><span class="w"> </span>
<span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">mlir</span><span class="o">::</span><span class="n">PassWrapper</span><span class="o">&lt;</span><span class="n">ShapeInferencePass</span><span class="p">,</span><span class="w"> </span><span class="n">OperationPass</span><span class="o">&lt;</span><span class="n">toy</span><span class="o">::</span><span class="n">FuncOp</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID</span><span class="p">(</span><span class="n">ShapeInferencePass</span><span class="p">)</span>

<span class="kt">void</span><span class="w"> </span><span class="n">runOnOperation</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getOperation</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// 0. 将所有需要 形状推导 的Op(返回 dynamic shape 的 Op) 加入 worklist</span>
<span class="w">  </span><span class="n">llvm</span><span class="o">::</span><span class="n">SmallPtrSet</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="o">&gt;</span><span class="w"> </span><span class="n">opWorklist</span><span class="p">;</span>
<span class="w">  </span><span class="n">f</span><span class="p">.</span><span class="n">walk</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">mlir</span><span class="o">::</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">returnsDynamicShape</span><span class="p">(</span><span class="n">op</span><span class="p">))</span>
<span class="w">      </span><span class="n">opWorklist</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
<span class="w">  </span><span class="p">});</span>

<span class="w">  </span><span class="c1">// 在 worklist 上迭代， 直到所有的 operations 都被推导（worklist 为空）</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">opWorklist</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 1. 找到下一个需要推导的 operation —— 这个 operation 的所有参数形状应该都已经被推导</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">nextop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">opWorklist</span><span class="p">,</span><span class="w"> </span><span class="n">allOperandsInferred</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 2. 没有找到说明已经收敛， 结束算法</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nextop</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">opWorklist</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 3. 从 worklist 中删除 该 op， 并调用该 op 的 inferShapes 方法 推导形状</span>
<span class="w">    </span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">nextop</span><span class="p">;</span>
<span class="w">    </span><span class="n">opWorklist</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 3.1. op 实现了 `ShapeInference` 接口上的方法 `inferShapes` 在这里被调用</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">shapeOp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ShapeInference</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">shapeOp</span><span class="p">.</span><span class="n">inferShapes</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">op</span><span class="o">-&gt;</span><span class="n">emitError</span><span class="p">(</span><span class="s">&quot;operation doesnt have shape inference interface&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">signalPassFailure</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// 4. 跳出循环后， 如果 operation worklist 不为空, 意味着算法失败.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">opWorklist</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">f</span><span class="p">.</span><span class="n">emitError</span><span class="p">(</span><span class="s">&quot;Shape inference failed, &quot;</span><span class="p">)</span>
<span class="w">        </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">opWorklist</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; operations couldn&#39;t be inferred</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">signalPassFailure</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
</li>
<li>
<p>把形状推导 Pass 加到优化 pipline</p>
<p>同样的，我们在最后把 shapeinference pass 添加到我们的 passmanager 中：</p>
<div class="highlight"><pre><span></span><code><span class="n">optPM</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">toy</span><span class="o">::</span><span class="n">createShapeInferencePass</span><span class="p">());</span>
</code></pre></div>
<p>MLIR 代码中还添加了一个 CSE pass， 这样就得到了本章开始的最终结果。</p>
</li>
</ol>
<h2 id="5-chapter-5-lowering-lower-level-dialects">5. Chapter 5: 部分 Lowering 到 Lower-Level Dialects 做优化</h2>
<p>接下来展示 MLIR 的特色， 即通过在同一函数中共存的方言混合来执行渐进式降低。 </p>
<p>在本章中，我们将 Toy Dialect 的部分 Operation Lowering 到 Affine Dialect 。Affine Dialect 是为 计算密集型 程序量身定制的：它不支持表示我们的 <code>toy.print</code>。 我们可以针对 Toy 的 计算密集型 部分使用 Affine，并在下一章中直接针对 LLVM IR 方言来降低 <code>toy.print</code>。 作为此 Lowering 的一部分，我们将从 Toy 操作的 <code>TensorType</code> 降低到通过仿射循环嵌套索引的 <code>MemRefType</code> 。 张量表示抽象值类型的数据序列，这意味着它们不存在于任何内存中， 而 <code>MemRefs</code> 表示较低级别的缓冲区访问，因为它们是对内存区域的具体引用。</p>
<p>MLIR 有众多的 Dialect，所以 MLIR 提供了一个统一的 <code>DialectConversion</code> 框架来支持这些 Dialect 互转。 <code>DialectConversion</code> 框架 允许将一组 <code>illegal</code> 操作转换为一组 <code>legal</code> 操作。要使用这个框架，我们需要提供两件事（以及可选的第三件事）：</p>
<ol>
<li><strong>转换目标（Conversation Target）</strong> 明确哪些 Dialect 操作是需要合法转换的，不合法的操作需要重写模式 (rewrite patterns) 来进行合法化。</li>
<li><strong>一组重写模式（Rewrite Pattern）</strong> 这是用于将非法操作转换为零个或多个合法操作的一组模式。</li>
<li><strong>类型转换器 （Type Converter）（可选）</strong> 这一节将不需要此转换。</li>
</ol>
<p>接下来依次来看</p>
<ol>
<li>
<p><strong>转换目标(Conversation Target)</strong></p>
<p>我们希望将计算密集型 Toy Operation 转换为 <code>Affine</code> 、 <code>Arith</code> 、 <code>Func</code> 和 <code>MemRef</code> 方言的 Operation 组合，以进一步优化。为了开始降低，我们首先定义我们的转换目标（这段代码位于 <code>mlir/examples/toy/Ch5/mlir/LowerToAffineLoops.cpp</code> ）：</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">ToyToAffineLoweringPass::runOnOperation</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 指定 转换目标（Conversation Target）</span>
<span class="w">  </span><span class="n">mlir</span><span class="o">::</span><span class="n">ConversionTarget</span><span class="w"> </span><span class="n">target</span><span class="p">(</span><span class="n">getContext</span><span class="p">());</span>

<span class="w">  </span><span class="c1">// 指定在这次 lowering 中 `Affine`, `Arith`, `Func`, 和 `MemRef` 方言是合法的</span>
<span class="w">  </span><span class="n">target</span><span class="p">.</span><span class="n">addLegalDialect</span><span class="o">&lt;</span><span class="n">AffineDialect</span><span class="p">,</span><span class="w"> </span><span class="n">arith</span><span class="o">::</span><span class="n">ArithDialect</span><span class="p">,</span>
<span class="w">                        </span><span class="n">func</span><span class="o">::</span><span class="n">FuncDialect</span><span class="p">,</span><span class="w"> </span><span class="n">memref</span><span class="o">::</span><span class="n">MemRefDialect</span><span class="o">&gt;</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// 将 Toy Dialect 标记为非法， 从而如果有 Toy Dialect 中的 Operation 没有被转换，就会报错</span>
<span class="w">  </span><span class="c1">// 将 `toy.print` 标记为合法 ， 不过这里需要改变 该操作的 操作数为 `MemRefType`</span>
<span class="w">  </span><span class="c1">// 由于 MLIR 中单个操作的定义始终优于 Dialect 的定义，因此上面代码中定义合法</span>
<span class="w">  </span><span class="n">target</span><span class="p">.</span><span class="n">addIllegalDialect</span><span class="o">&lt;</span><span class="n">ToyDialect</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="n">target</span><span class="p">.</span><span class="n">addDynamicallyLegalOp</span><span class="o">&lt;</span><span class="n">toy</span><span class="o">::</span><span class="n">PrintOp</span><span class="o">&gt;</span><span class="p">([](</span><span class="n">toy</span><span class="o">::</span><span class="n">PrintOp</span><span class="w"> </span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">none_of</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">getOperandTypes</span><span class="p">(),</span>
<span class="w">                        </span><span class="p">[](</span><span class="n">Type</span><span class="w"> </span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">type</span><span class="p">.</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">TensorType</span><span class="o">&gt;</span><span class="p">();</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="p">});</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div>
</li>
<li>
<p><strong>转换模式(Conversion Patterns)</strong></p>
<p>在定义了转换目标之后，我们可以定义如何将非法操作转换为合法操作。 与第 3 章介绍的ODS框架类似， <code>DialectConversion</code> 框架也使用 RewritePatterns 来执行转换逻辑。 这些模式可能是之前看到的 RewritePatterns 或特定于转换框架 <code>ConversionPattern</code> 的新模式。 <code>ConversionPatterns</code> 与传统的 RewritePatterns 不同，因为它们接受一个额外的操作数参数，其中包含已重新映射 / 替换的 operands。 官方文档中给出了 Lowering Toy Dialect 中 transpose 操作的例子，代码如下。</p>
<div class="highlight"><pre><span></span><code><span class="c1">/// 将 `toy.transpose` operation 降低为 an affine loop nest.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">TransposeOpLowering</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">mlir</span><span class="o">::</span><span class="n">ConversionPattern</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">TransposeOpLowering</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">mlir</span><span class="o">::</span><span class="n">ConversionPattern</span><span class="p">(</span><span class="n">TransposeOp</span><span class="o">::</span><span class="n">getOperationName</span><span class="p">(),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ctx</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="c1">/// 匹配重写 `toy.transpose` operation, with the given</span>
<span class="w">  </span><span class="c1">/// operands that have been remapped from `tensor&lt;...&gt;` to `memref&lt;...&gt;`.</span>
<span class="w">  </span><span class="n">mlir</span><span class="o">::</span><span class="n">LogicalResult</span>
<span class="w">  </span><span class="n">matchAndRewrite</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operands</span><span class="p">,</span>
<span class="w">                  </span><span class="n">mlir</span><span class="o">::</span><span class="n">ConversionPatternRewriter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rewriter</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">final</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op</span><span class="o">-&gt;</span><span class="n">getLoc</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 调用辅助函数，将当前操作降低到 一组仿射循环</span>
<span class="w">    </span><span class="c1">// 我们提供了一个对重新映射的 操作数进行操作的仿函数，以及最内层 循环体的循环归纳变量。</span>
<span class="w">    </span><span class="n">lowerOpToLoops</span><span class="p">(</span>
<span class="w">        </span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">operands</span><span class="p">,</span><span class="w"> </span><span class="n">rewriter</span><span class="p">,</span>
<span class="w">        </span><span class="p">[</span><span class="n">loc</span><span class="p">](</span><span class="n">mlir</span><span class="o">::</span><span class="n">PatternRewriter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rewriter</span><span class="p">,</span>
<span class="w">              </span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span><span class="w"> </span><span class="n">memRefOperands</span><span class="p">,</span>
<span class="w">              </span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span><span class="w"> </span><span class="n">loopIvs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">          </span><span class="n">TransposeOpAdaptor</span><span class="w"> </span><span class="nf">transposeAdaptor</span><span class="p">(</span><span class="n">memRefOperands</span><span class="p">);</span>
<span class="w">          </span><span class="n">mlir</span><span class="o">::</span><span class="n">Value</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transposeAdaptor</span><span class="p">.</span><span class="n">input</span><span class="p">();</span>

<span class="w">          </span><span class="c1">// Transpose the elements by generating a load from the reverse indices.</span>
<span class="w">          </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">Value</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">reverseIvs</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">loopIvs</span><span class="p">));</span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="n">rewriter</span><span class="p">.</span><span class="n">create</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">AffineLoadOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">reverseIvs</span><span class="p">);</span>
<span class="w">        </span><span class="p">});</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">success</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>我们把这个转换，包括其它Op到Affine的转换也添加到  <code>ToyToAffineLoweringPass</code> 中：</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">ToyToAffineLoweringPass::runOnOperation</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>

<span class="w">  </span><span class="c1">// 把 Conversion Patterns 添加到  `ToyToAffineLoweringPass`</span>
<span class="w">  </span><span class="n">RewritePatternSet</span><span class="w"> </span><span class="n">patterns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">getContext</span><span class="p">());</span>
<span class="w">  </span><span class="n">patterns</span><span class="p">.</span><span class="n">add</span><span class="o">&lt;</span><span class="n">AddOpLowering</span><span class="p">,</span><span class="w"> </span><span class="n">ConstantOpLowering</span><span class="p">,</span><span class="w"> </span><span class="n">FuncOpLowering</span><span class="p">,</span><span class="w"> </span><span class="n">MulOpLowering</span><span class="p">,</span>
<span class="w">              </span><span class="n">PrintOpLowering</span><span class="p">,</span><span class="w"> </span><span class="n">ReturnOpLowering</span><span class="p">,</span><span class="w"> </span><span class="n">TransposeOpLowering</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">getContext</span><span class="p">());</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">failed</span><span class="p">(...))</span><span class="w"> </span><span class="n">signalPassFailure</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
</li>
<li>
<p>最终在 该Pass 中调用 MLIR 提供的 <code>applyPartialConversion</code>：</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">ToyToAffineLoweringPass::runOnOperation</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 1. 定义转换目标(Conversation Target)</span>
<span class="w">  </span><span class="n">ConversionTarget</span><span class="w"> </span><span class="n">target</span><span class="p">(</span><span class="n">getContext</span><span class="p">());</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="c1">// 2. 添加转换模式(Conversion Patterns)</span>
<span class="w">  </span><span class="n">RewritePatternSet</span><span class="w"> </span><span class="n">patterns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">getContext</span><span class="p">());</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="c1">// 3. applyPartialConversion</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">failed</span><span class="p">(</span><span class="n">applyPartialConversion</span><span class="p">(</span><span class="n">getOperation</span><span class="p">(),</span><span class="w"> </span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">patterns</span><span class="p">))))</span>
<span class="w">    </span><span class="n">signalPassFailure</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>最后将这个 Pass 添加到 PassManager 中即可， 类似前面几节中 添加 Inline Pass：</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isLoweringToAffine</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Partially lower the toy dialect.</span>
<span class="w">    </span><span class="n">pm</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">toy</span><span class="o">::</span><span class="n">createLowerToAffinePass</span><span class="p">());</span>

<span class="w">    </span><span class="c1">// Add a few cleanups post lowering.</span>
<span class="w">    </span><span class="n">mlir</span><span class="o">::</span><span class="n">OpPassManager</span><span class="w"> </span><span class="o">&amp;</span><span class="n">optPM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pm</span><span class="p">.</span><span class="n">nest</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">func</span><span class="o">::</span><span class="n">FuncOp</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">    </span><span class="n">optPM</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">createCanonicalizerPass</span><span class="p">());</span>
<span class="w">    </span><span class="n">optPM</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">createCSEPass</span><span class="p">());</span>

<span class="w">    </span><span class="c1">// Add optimizations if enabled.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">enableOpt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">optPM</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">createLoopFusionPass</span><span class="p">());</span>
<span class="w">      </span><span class="n">optPM</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">createAffineScalarReplacementPass</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
</code></pre></div>
</li>
</ol>
<p>本节的例子使用 <code>mlir/test/Examples/Toy/Ch5/affine-lowering.mlir</code></p>
<div class="highlight"><pre><span></span><code><span class="n">toy</span><span class="p">.</span><span class="n">func</span><span class="w"> </span><span class="err">@</span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// %0 = [[1, 2, 3], [4, 5, 6]]  // -&gt; (2*3)</span>
<span class="w">  </span><span class="c1">// %2 = transpose(%0)           // -&gt; (3*2)</span>
<span class="w">  </span><span class="c1">// %3 = %2 * %2                 // -&gt; (3*2) element-wise mul</span>
<span class="w">  </span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">toy</span><span class="p">.</span><span class="n">constant</span><span class="w"> </span><span class="n">dense</span><span class="o">&lt;</span><span class="p">[[</span><span class="mf">1.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">2.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">3.000000e+00</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mf">4.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">5.000000e+00</span><span class="p">,</span><span class="w"> </span><span class="mf">6.000000e+00</span><span class="p">]]</span><span class="o">&gt;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;</span><span class="mi">2</span><span class="n">x3xf64</span><span class="o">&gt;</span>
<span class="w">  </span><span class="o">%</span><span class="mi">2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">toy</span><span class="p">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;</span><span class="mi">2</span><span class="n">x3xf64</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;</span><span class="mi">3</span><span class="n">x2xf64</span><span class="o">&gt;</span>
<span class="w">  </span><span class="o">%</span><span class="mi">3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">toy</span><span class="p">.</span><span class="n">mul</span><span class="w"> </span><span class="o">%</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;</span><span class="mi">3</span><span class="n">x2xf64</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">toy</span><span class="p">.</span><span class="n">print</span><span class="w"> </span><span class="o">%</span><span class="mi">3</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">tensor</span><span class="o">&lt;</span><span class="mi">3</span><span class="n">x2xf64</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">toy</span><span class="p">.</span><span class="k">return</span>
<span class="p">}</span>
</code></pre></div>
<p>执行 <code>./bin/toyc-ch5 ../mlir/test/Examples/Toy/Ch5/affine-lowering.mlir -emit=mlir-affine</code> 之后就可以查看应用了本节的部分 Lowering 之后混合了多种方言的 MLIR 表达式了</p>
<div class="highlight"><pre><span></span><code><span class="nx">module</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">func</span><span class="p">.</span><span class="kd">func</span><span class="w"> </span><span class="err">@</span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">%</span><span class="nx">cst</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">arith</span><span class="p">.</span><span class="nx">constant</span><span class="w"> </span><span class="mf">6.000000e+00</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">f64</span>
<span class="w">    </span><span class="o">%</span><span class="nx">cst_0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">arith</span><span class="p">.</span><span class="nx">constant</span><span class="w"> </span><span class="mf">5.000000e+00</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">f64</span>
<span class="w">    </span><span class="o">%</span><span class="nx">cst_1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">arith</span><span class="p">.</span><span class="nx">constant</span><span class="w"> </span><span class="mf">4.000000e+00</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">f64</span>
<span class="w">    </span><span class="o">%</span><span class="nx">cst_2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">arith</span><span class="p">.</span><span class="nx">constant</span><span class="w"> </span><span class="mf">3.000000e+00</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">f64</span>
<span class="w">    </span><span class="o">%</span><span class="nx">cst_3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">arith</span><span class="p">.</span><span class="nx">constant</span><span class="w"> </span><span class="mf">2.000000e+00</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">f64</span>
<span class="w">    </span><span class="o">%</span><span class="nx">cst_4</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">arith</span><span class="p">.</span><span class="nx">constant</span><span class="w"> </span><span class="mf">1.000000e+00</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">f64</span>
<span class="w">    </span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">memref</span><span class="p">.</span><span class="nx">alloc</span><span class="p">()</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">3</span><span class="nx">x2xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="o">%</span><span class="mi">1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">memref</span><span class="p">.</span><span class="nx">alloc</span><span class="p">()</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">3</span><span class="nx">x2xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="o">%</span><span class="mi">2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">memref</span><span class="p">.</span><span class="nx">alloc</span><span class="p">()</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;</span>

<span class="w">    </span><span class="c1">// %2 = [[1, 2, 3], [4, 5, 6]]</span>
<span class="w">    </span><span class="nx">affine</span><span class="p">.</span><span class="nx">store</span><span class="w"> </span><span class="o">%</span><span class="nx">cst_4</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">affine</span><span class="p">.</span><span class="nx">store</span><span class="w"> </span><span class="o">%</span><span class="nx">cst_3</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">affine</span><span class="p">.</span><span class="nx">store</span><span class="w"> </span><span class="o">%</span><span class="nx">cst_2</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">affine</span><span class="p">.</span><span class="nx">store</span><span class="w"> </span><span class="o">%</span><span class="nx">cst_1</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">affine</span><span class="p">.</span><span class="nx">store</span><span class="w"> </span><span class="o">%</span><span class="nx">cst_0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">affine</span><span class="p">.</span><span class="nx">store</span><span class="w"> </span><span class="o">%</span><span class="nx">cst</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;</span>

<span class="w">    </span><span class="c1">// %1 = transpose(%2)</span>
<span class="w">    </span><span class="nx">affine</span><span class="p">.</span><span class="k">for</span><span class="w"> </span><span class="o">%</span><span class="nx">arg0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">affine</span><span class="p">.</span><span class="k">for</span><span class="w"> </span><span class="o">%</span><span class="nx">arg1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">%</span><span class="mi">3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">affine</span><span class="p">.</span><span class="nx">load</span><span class="w"> </span><span class="o">%</span><span class="mi">2</span><span class="p">[</span><span class="o">%</span><span class="nx">arg1</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nx">arg0</span><span class="p">]</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;</span>
<span class="w">        </span><span class="nx">affine</span><span class="p">.</span><span class="nx">store</span><span class="w"> </span><span class="o">%</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">1</span><span class="p">[</span><span class="o">%</span><span class="nx">arg0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nx">arg1</span><span class="p">]</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">3</span><span class="nx">x2xf64</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// %0 = %1 * %1</span>
<span class="w">    </span><span class="nx">affine</span><span class="p">.</span><span class="k">for</span><span class="w"> </span><span class="o">%</span><span class="nx">arg0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">affine</span><span class="p">.</span><span class="k">for</span><span class="w"> </span><span class="o">%</span><span class="nx">arg1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">%</span><span class="mi">3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">affine</span><span class="p">.</span><span class="nx">load</span><span class="w"> </span><span class="o">%</span><span class="mi">1</span><span class="p">[</span><span class="o">%</span><span class="nx">arg0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nx">arg1</span><span class="p">]</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">3</span><span class="nx">x2xf64</span><span class="p">&gt;</span>
<span class="w">        </span><span class="o">%</span><span class="mi">4</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">arith</span><span class="p">.</span><span class="nx">mulf</span><span class="w"> </span><span class="o">%</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">3</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">f64</span>
<span class="w">        </span><span class="nx">affine</span><span class="p">.</span><span class="nx">store</span><span class="w"> </span><span class="o">%</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">0</span><span class="p">[</span><span class="o">%</span><span class="nx">arg0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nx">arg1</span><span class="p">]</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">3</span><span class="nx">x2xf64</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">toy</span><span class="p">.</span><span class="nx">print</span><span class="w"> </span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">3</span><span class="nx">x2xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">memref</span><span class="p">.</span><span class="nx">dealloc</span><span class="w"> </span><span class="o">%</span><span class="mi">2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">memref</span><span class="p">.</span><span class="nx">dealloc</span><span class="w"> </span><span class="o">%</span><span class="mi">1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">3</span><span class="nx">x2xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">memref</span><span class="p">.</span><span class="nx">dealloc</span><span class="w"> </span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">3</span><span class="nx">x2xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="k">return</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<blockquote>
<p>首先有 6 个 <code>f64</code> 数据类型的常量，使用 <code>%cst</code> 开头的变量来表示。 然后为输入和输出分配缓冲区，如 <code>%0 = memref.alloc() : memref&lt;3x2xf64&gt;</code> 申请一个类型为 <code>memref&lt;3x2xf64&gt;</code> 的缓冲区。然后 <code>affine.store</code> 将之前声明的 6 个数据依次存入上述分配的缓冲区中。</p>
<p>之后，第一个循环，将加载的输入数据（数据加载操作 <code>affine.load</code> ），保存到另一个数据容器中，最终实现转置操作。接着，第二个循环，加载之前定义在两个数据容器中的数据，相乘并存放到输出的数据容器中。最终使用 <code>toy.print</code> 打印结果，并释放缓冲区。</p>
</blockquote>
<p>使用了 Affine Dialect 之后，我们可以将 Operation 更底层的逻辑展示出来，将代码中的冗余更轻易的暴露出来。这里可以优化的地方为两个循环嵌套的循环边界相同，可以进行循环融合， 融合后， 中间变量<code>%1 = transpose(%2)</code> 是冗余的可以去掉。</p>
<p>在 <code>mlir/examples/toy/Ch5/toyc.cpp</code> 中添加了 <code>createLoopFusionPass</code> 和 <code>createAffineScalarReplacementPass</code> ，这两种 MLIR 自带的 Pass 分别完成了相同循环边界融合优化以及对于 MemRef 的数据流优化功能。我们只需要在上面那个生成部分 Lowering 的 Affine Dialect 命令中额外加一个 <code>-opt</code> 就可以生成加入了这两个优化 Pass 的 Affine Dialect 了。命令如下：<code>./bin/toyc-ch5 ../mlir/test/Examples/Toy/Ch5/affine-lowering.mlir -emit=mlir-affine -opt</code> 。生成的 MLIR 表达式为：</p>
<div class="highlight"><pre><span></span><code><span class="nx">module</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">func</span><span class="p">.</span><span class="kd">func</span><span class="w"> </span><span class="err">@</span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">%</span><span class="nx">cst</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">arith</span><span class="p">.</span><span class="nx">constant</span><span class="w"> </span><span class="mf">6.000000e+00</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">f64</span>
<span class="w">    </span><span class="o">%</span><span class="nx">cst_0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">arith</span><span class="p">.</span><span class="nx">constant</span><span class="w"> </span><span class="mf">5.000000e+00</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">f64</span>
<span class="w">    </span><span class="o">%</span><span class="nx">cst_1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">arith</span><span class="p">.</span><span class="nx">constant</span><span class="w"> </span><span class="mf">4.000000e+00</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">f64</span>
<span class="w">    </span><span class="o">%</span><span class="nx">cst_2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">arith</span><span class="p">.</span><span class="nx">constant</span><span class="w"> </span><span class="mf">3.000000e+00</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">f64</span>
<span class="w">    </span><span class="o">%</span><span class="nx">cst_3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">arith</span><span class="p">.</span><span class="nx">constant</span><span class="w"> </span><span class="mf">2.000000e+00</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">f64</span>
<span class="w">    </span><span class="o">%</span><span class="nx">cst_4</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">arith</span><span class="p">.</span><span class="nx">constant</span><span class="w"> </span><span class="mf">1.000000e+00</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">f64</span>
<span class="w">    </span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">memref</span><span class="p">.</span><span class="nx">alloc</span><span class="p">()</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">3</span><span class="nx">x2xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="o">%</span><span class="mi">1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">memref</span><span class="p">.</span><span class="nx">alloc</span><span class="p">()</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;</span>

<span class="w">    </span><span class="nx">affine</span><span class="p">.</span><span class="nx">store</span><span class="w"> </span><span class="o">%</span><span class="nx">cst_4</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">affine</span><span class="p">.</span><span class="nx">store</span><span class="w"> </span><span class="o">%</span><span class="nx">cst_3</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">affine</span><span class="p">.</span><span class="nx">store</span><span class="w"> </span><span class="o">%</span><span class="nx">cst_2</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">affine</span><span class="p">.</span><span class="nx">store</span><span class="w"> </span><span class="o">%</span><span class="nx">cst_1</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">affine</span><span class="p">.</span><span class="nx">store</span><span class="w"> </span><span class="o">%</span><span class="nx">cst_0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">affine</span><span class="p">.</span><span class="nx">store</span><span class="w"> </span><span class="o">%</span><span class="nx">cst</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;</span>

<span class="w">    </span><span class="nx">affine</span><span class="p">.</span><span class="k">for</span><span class="w"> </span><span class="o">%</span><span class="nx">arg0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">affine</span><span class="p">.</span><span class="k">for</span><span class="w"> </span><span class="o">%</span><span class="nx">arg1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">%</span><span class="mi">2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">affine</span><span class="p">.</span><span class="nx">load</span><span class="w"> </span><span class="o">%</span><span class="mi">1</span><span class="p">[</span><span class="o">%</span><span class="nx">arg1</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nx">arg0</span><span class="p">]</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;</span>
<span class="w">        </span><span class="o">%</span><span class="mi">3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">arith</span><span class="p">.</span><span class="nx">mulf</span><span class="w"> </span><span class="o">%</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">f64</span>
<span class="w">        </span><span class="nx">affine</span><span class="p">.</span><span class="nx">store</span><span class="w"> </span><span class="o">%</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">0</span><span class="p">[</span><span class="o">%</span><span class="nx">arg0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nx">arg1</span><span class="p">]</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">3</span><span class="nx">x2xf64</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">toy</span><span class="p">.</span><span class="nx">print</span><span class="w"> </span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">3</span><span class="nx">x2xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">memref</span><span class="p">.</span><span class="nx">dealloc</span><span class="w"> </span><span class="o">%</span><span class="mi">1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="nx">x3xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">memref</span><span class="p">.</span><span class="nx">dealloc</span><span class="w"> </span><span class="o">%</span><span class="mi">0</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">memref</span><span class="p">&lt;</span><span class="mi">3</span><span class="nx">x2xf64</span><span class="p">&gt;</span>
<span class="w">    </span><span class="k">return</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>可以看到，这里删除了多余的数据缓冲区的分配，两个循环嵌套被融合在一起，另外去除了一些不必要的数据加载操作。</p>
<p>所以我们通过部分 Lowering 确实寻求到了更多的优化机会，使得 MLIR 表达式的运行效率更高。</p>
<h2 id="6-chapter-6-lowering-to-llvm-and-codegeneration">6. Chapter 6: Lowering to LLVM and CodeGeneration</h2>
<p>上一节中，我们将 Toy Dialect 的部分 Operation Lowering 到 Affine Dialect， MemRef Dialect 和 Standard Dialect，而 <code>toy.print</code> 操作保持不变。这一节，我们将在上一节得到的混合型 MLIR 表达式完全 Lowering 到 LLVM Dialect 上，然后生成 LLVM IR，并且我们可以使用 MLIR 的 JIT 编译引擎来运行最终的 MLIR 表达式并输出计算结果。</p>
<h3 id="61-lowering-toyprint">6.1. Lowering toy.print</h3>
<p>接下来我们尝试把 <code>toy.print</code> Operation 降低到 SCF (structured control flow) Dialect。 即， 我们将把 <code>toy.print</code> Operation 降低到一个非仿射循环嵌套，它为每个元素调用 <code>printf</code> 。请注意，因为方言转换框架支持 <a href="https://mlir.llvm.org/getting_started/Glossary/#transitive-lowering">Transitive lowering</a> ，我们不需要直接在 LLVM Dialect 中发出操作。 Transitive lowering 的思想是转换框架可以应用多种模式来完全合法化操作。 在此示例中，我们生成 SCF 而不是 LLVM Dialect 中的分支形式。只要我们从循环操作降低到 LLVM， 降低仍然会成功。</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">PrintOpLowering</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">ConversionPattern</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="c1">/// 匹配 `toy::PrintOp` Operation， 重写为对 operands (memRefType) 逐元素 调用 `printf`</span>
<span class="w">  </span><span class="n">LogicalResult</span><span class="w"> </span><span class="nf">matchAndRewrite</span><span class="p">(</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">Value</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operands</span><span class="p">,</span>
<span class="w">    </span><span class="n">ConversionPatternRewriter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rewriter</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{...}</span>

<span class="w">  </span><span class="p">...</span>

<span class="w">  </span><span class="c1">/// 返回对 `printf` 的符号引用, inserting it into the module if necessary.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">FlatSymbolRefAttr</span><span class="w"> </span><span class="n">getOrInsertPrintf</span><span class="p">(</span><span class="n">PatternRewriter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rewriter</span><span class="p">,</span>
<span class="w">                                            </span><span class="n">ModuleOp</span><span class="w"> </span><span class="k">module</span><span class="p">,</span>
<span class="w">                                            </span><span class="n">LLVM</span><span class="o">::</span><span class="n">LLVMDialect</span><span class="w"> </span><span class="o">*</span><span class="n">llvmDialect</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">module</span><span class="p">.</span><span class="n">getContext</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">module</span><span class="p">.</span><span class="n">lookupSymbol</span><span class="o">&lt;</span><span class="n">LLVM</span><span class="o">::</span><span class="n">LLVMFuncOp</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;printf&quot;</span><span class="p">))</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">SymbolRefAttr</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;printf&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 声明 `printf`, the signature is:</span>
<span class="w">    </span><span class="c1">//   * `i32 (i8*, ...)`</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">llvmI32Ty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IntegerType</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">llvmI8PtrTy</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">LLVM</span><span class="o">::</span><span class="n">LLVMPointerType</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">IntegerType</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">));</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">llvmFnType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LLVM</span><span class="o">::</span><span class="n">LLVMFunctionType</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">llvmI32Ty</span><span class="p">,</span><span class="w"> </span><span class="n">llvmI8PtrTy</span><span class="p">,</span>
<span class="w">                                                  </span><span class="cm">/*isVarArg=*/</span><span class="nb">true</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Insert the `printf` function into the body of the parent module.</span>
<span class="w">    </span><span class="n">PatternRewriter</span><span class="o">::</span><span class="n">InsertionGuard</span><span class="w"> </span><span class="nf">insertGuard</span><span class="p">(</span><span class="n">rewriter</span><span class="p">);</span>
<span class="w">    </span><span class="n">rewriter</span><span class="p">.</span><span class="n">setInsertionPointToStart</span><span class="p">(</span><span class="k">module</span><span class="p">.</span><span class="n">getBody</span><span class="p">());</span>
<span class="w">    </span><span class="n">rewriter</span><span class="p">.</span><span class="n">create</span><span class="o">&lt;</span><span class="n">LLVM</span><span class="o">::</span><span class="n">LLVMFuncOp</span><span class="o">&gt;</span><span class="p">(</span><span class="k">module</span><span class="p">.</span><span class="n">getLoc</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;printf&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">llvmFnType</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">SymbolRefAttr</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;printf&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="p">}</span>
</code></pre></div>
<p>接下来与 <code>ToyToAffineLoweringPass</code> 类似， 我们在 <code>ToyToLLVMLoweringPass</code> 中依次执行：
1. 定义转换目标(Conversion Target)
2. 添加转换模式(Conversion Patterns)
3. apply Conversion ； 这里与 <code>ToyToAffineLoweringPass</code> 不同， 这里执行 <code>applyFullConversion</code> 而不是 部分降低</p>
<p>添加 类型转换 和 对于 <code>toy.print</code> 的转换：</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">ToyToLLVMLoweringPass::runOnOperation</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 1. 定义 conversion target， 这里 target 就是 LLVM dialect</span>
<span class="w">  </span><span class="n">LLVMConversionTarget</span><span class="w"> </span><span class="n">target</span><span class="p">(</span><span class="n">getContext</span><span class="p">());</span>
<span class="w">  </span><span class="n">target</span><span class="p">.</span><span class="n">addLegalOp</span><span class="o">&lt;</span><span class="n">ModuleOp</span><span class="o">&gt;</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// 定义 TypeConverter 将 MemRef 转换为 representation in LLVM</span>
<span class="w">  </span><span class="n">LLVMTypeConverter</span><span class="w"> </span><span class="n">typeConverter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">getContext</span><span class="p">());</span>

<span class="w">  </span><span class="c1">// 2. 添加 Conversion Patterns, 这里可以利用 MLIR 中已经存在的 模式匹配-转换</span>
<span class="w">  </span><span class="c1">// </span>
<span class="w">  </span><span class="c1">// 当前我们的 MLIR 表示 由多种 Dialect 构成， 包括 `toy`, `affine` 等</span>
<span class="w">  </span><span class="c1">// affine、arith 和 std 方言已经提供了将它们转换为 LLVM 方言所需的一组模式</span>
<span class="w">  </span><span class="n">RewritePatternSet</span><span class="w"> </span><span class="n">patterns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">getContext</span><span class="p">());</span>
<span class="w">  </span><span class="n">populateAffineToStdConversionPatterns</span><span class="p">(</span><span class="n">patterns</span><span class="p">);</span>
<span class="w">  </span><span class="n">populateSCFToControlFlowConversionPatterns</span><span class="p">(</span><span class="n">patterns</span><span class="p">);</span>
<span class="w">  </span><span class="n">mlir</span><span class="o">::</span><span class="n">arith</span><span class="o">::</span><span class="n">populateArithmeticToLLVMConversionPatterns</span><span class="p">(</span><span class="n">typeConverter</span><span class="p">,</span><span class="w"> </span><span class="n">patterns</span><span class="p">);</span>
<span class="w">  </span><span class="n">populateMemRefToLLVMConversionPatterns</span><span class="p">(</span><span class="n">typeConverter</span><span class="p">,</span><span class="w"> </span><span class="n">patterns</span><span class="p">);</span>
<span class="w">  </span><span class="n">cf</span><span class="o">::</span><span class="n">populateControlFlowToLLVMConversionPatterns</span><span class="p">(</span><span class="n">typeConverter</span><span class="p">,</span><span class="w"> </span><span class="n">patterns</span><span class="p">);</span>
<span class="w">  </span><span class="n">populateFuncToLLVMConversionPatterns</span><span class="p">(</span><span class="n">typeConverter</span><span class="p">,</span><span class="w"> </span><span class="n">patterns</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// 添加对于 `toy.PrintOp` 的匹配重写</span>
<span class="w">  </span><span class="n">patterns</span><span class="p">.</span><span class="n">add</span><span class="o">&lt;</span><span class="n">PrintOpLowering</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">getContext</span><span class="p">());</span>

<span class="w">  </span><span class="c1">// 3. `FullConversion`. 可以保证在 conversion 之后只有 legal operations</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getOperation</span><span class="p">();</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">failed</span><span class="p">(</span><span class="n">applyFullConversion</span><span class="p">(</span><span class="k">module</span><span class="p">,</span><span class="w"> </span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">patterns</span><span class="p">))))</span>
<span class="w">    </span><span class="n">signalPassFailure</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>类似的， 我们还需要将这个 pass 加入我们的 pass pipeline， 并在前端加上相应代码， 接着就可以生成 LLVM Dialect 了 <code>./bin/toyc-ch6 ../mlir/test/Examples/Toy/Ch6/llvm-lowering.mlir -emit=mlir-llvm</code>：</p>
<h3 id="62-llvm-ir-jit">6.2. 生成LLVM IR 并 JIT</h3>
<p>接下来将 LLVM Dialect 转换成 LLVM IR， 并设置 JIT 来运行它。</p>
<p><div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">runJit</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">ModuleOp</span><span class="w"> </span><span class="k">module</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Initialize LLVM targets.</span>
<span class="w">  </span><span class="n">llvm</span><span class="o">::</span><span class="n">InitializeNativeTarget</span><span class="p">();</span>
<span class="w">  </span><span class="n">llvm</span><span class="o">::</span><span class="n">InitializeNativeTargetAsmPrinter</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// 将 LLVM Dialect 翻译成 LLVM IR， JIT 时缓存， 下次执行时不会重复执行各种 MLIR 表达式变换</span>
<span class="w">  </span><span class="n">mlir</span><span class="o">::</span><span class="n">registerLLVMDialectTranslation</span><span class="p">(</span><span class="o">*</span><span class="k">module</span><span class="o">-&gt;</span><span class="n">getContext</span><span class="p">());</span>

<span class="w">  </span><span class="c1">// An optimization pipeline to use within the execution engine.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">optPipeline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mlir</span><span class="o">::</span><span class="n">makeOptimizingTransformer</span><span class="p">(</span>
<span class="w">      </span><span class="cm">/*optLevel=*/</span><span class="n">enableOpt</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="cm">/*sizeLevel=*/</span><span class="mi">0</span><span class="p">,</span>
<span class="w">      </span><span class="cm">/*targetMachine=*/</span><span class="k">nullptr</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// 创建一个 MLIR 执行引擎. 执行引擎 eagerly JIT-compiles the module.</span>
<span class="w">  </span><span class="n">mlir</span><span class="o">::</span><span class="n">ExecutionEngineOptions</span><span class="w"> </span><span class="n">engineOptions</span><span class="p">;</span>
<span class="w">  </span><span class="n">engineOptions</span><span class="p">.</span><span class="n">transformer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">optPipeline</span><span class="p">;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">maybeEngine</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mlir</span><span class="o">::</span><span class="n">ExecutionEngine</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="k">module</span><span class="p">,</span><span class="w"> </span><span class="n">engineOptions</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">maybeEngine</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="s">&quot;failed to construct an execution engine&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">engine</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">maybeEngine</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Invoke the JIT-compiled function.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">invocationResult</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">engine</span><span class="o">-&gt;</span><span class="n">invokePacked</span><span class="p">(</span><span class="s">&quot;main&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">invocationResult</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">llvm</span><span class="o">::</span><span class="n">errs</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;JIT invocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
执行<code>./bin/toyc-ch6 ../mlir/test/Examples/Toy/Ch6/llvm-lowering.mlir -emit=llvm -opt</code> 得到结果：</p>
<div class="highlight"><pre><span></span><code><span class="c">; Function Attrs: nounwind</span>
<span class="k">define</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@main</span><span class="p">()</span><span class="w"> </span><span class="k">local_unnamed_addr</span><span class="w"> </span><span class="vg">#1</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span><span class="w"> </span><span class="p">{</span>
<span class="nl">.preheader3:</span>
<span class="w">  </span><span class="nv nv-Anonymous">%0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">(</span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="vg">@printf</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">nonnull</span><span class="w"> </span><span class="vg">@frmt_spec</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="m">1.000000e+00</span><span class="p">),</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!7</span>
<span class="w">  </span><span class="nv nv-Anonymous">%1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">(</span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="vg">@printf</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">nonnull</span><span class="w"> </span><span class="vg">@frmt_spec</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="m">1.600000e+01</span><span class="p">),</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!7</span>
<span class="w">  </span><span class="nv">%putchar</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@putchar</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">10</span><span class="p">),</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!7</span>
<span class="w">  </span><span class="nv nv-Anonymous">%2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">(</span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="vg">@printf</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">nonnull</span><span class="w"> </span><span class="vg">@frmt_spec</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="m">4.000000e+00</span><span class="p">),</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!7</span>
<span class="w">  </span><span class="nv nv-Anonymous">%3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">(</span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="vg">@printf</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">nonnull</span><span class="w"> </span><span class="vg">@frmt_spec</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="m">2.500000e+01</span><span class="p">),</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!7</span>
<span class="w">  </span><span class="nv">%putchar.1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@putchar</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">10</span><span class="p">),</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!7</span>
<span class="w">  </span><span class="nv nv-Anonymous">%4</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">(</span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="vg">@printf</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">nonnull</span><span class="w"> </span><span class="vg">@frmt_spec</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="m">9.000000e+00</span><span class="p">),</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!7</span>
<span class="w">  </span><span class="nv nv-Anonymous">%5</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">(</span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="vg">@printf</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">nonnull</span><span class="w"> </span><span class="vg">@frmt_spec</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="m">3.600000e+01</span><span class="p">),</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!7</span>
<span class="w">  </span><span class="nv">%putchar.2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@putchar</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">10</span><span class="p">),</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!7</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="k">void</span><span class="p">,</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!9</span>
<span class="p">}</span>
</code></pre></div>
<p>执行 <code>./bin/toyc-ch6 ../mlir/test/Examples/Toy/Ch6/llvm-lowering.mlir -emit=jit -opt</code> 得到结果：</p>
<div class="highlight"><pre><span></span><code>1.000000 16.000000 
4.000000 25.000000 
9.000000 36.000000
</code></pre></div>
<h2 id="7-chapter-7-toy">7. Chapter 7: 为 Toy 添加复合类型</h2>
<p>在上一章中，我们演示了从 Toy 前端到 LLVM IR 的端到端编译流程。在本章中，我们将扩展 Toy 语言以支持新的复合结构类型。</p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.sections", "navigation.indexes"], "search": "../assets/javascripts/workers/search.208ed371.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.fac441b0.min.js"></script>
      
        <script src="../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>