# Rust-Option

## Rust 的 Option枚举

Option是一个枚举类型，定义如下，

```rust
enum Option<T> {
    Some(T),
    None,
}
```

### 初始化Option：

使用`let x = Some(T)`，编译器可以自动推断x对应的枚举类型，如`let some_string = Some("a string");`

但使用`None`则不可以如此：

因为编译器只通过 `None` 值无法推断出 `Some` 成员保存的值的类型。

需要事先声明`Option`的类型，如`let absent_number: Option<i32> = None;`



### 解开Option：

- 可以使用 `match` 语句来解开 `Option`
- 可以使用`unwrap()`来获得`Option`中的`Some`，但如果使用这种方式，获得`None`的时候程序将会panic



### 使用`Option<T>` 为什么比使用空值要好？

**Option解决了空值引发的一系列问题？？？**

空值的问题在于当你尝试像一个非空值那样使用一个空值，会出现某种形式的错误？？？

而因为 `Option<T>` 和 `T`（这里 `T` 可以是任何类型）是不同的类型，编译器不允许像使用一个肯定有效的值那样使用 `Option<T>`。例如，这段代码不能编译，因为它尝试将 `Option<i8>` 与 `i8` 相加：

```rust
let x: i8 = 5;
let y: Option<i8> = Some(5);
let sum = x + y;
```

> 当在 Rust 中拥有一个像 `i8` 这样类型的值时，编译器确保它总是有一个有效的值。我们可以自信使用而无需做空值检查。只有当使用 `Option<i8>`（或者任何用到的类型）的时候需要担心可能没有值，而编译器会确保我们在使用值之前处理了为空的情况。
>
> 在对 `Option<T>` 进行 `T` 的运算之前必须将其转换为 `T`。通常这能帮助我们捕获到空值最常见的问题之一：假设某值不为空但实际上为空的情况。
>
> 为了拥有一个可能为空的值，你必须要显式的将其放入对应类型的 `Option<T>` 中。接着，当使用这个值时，必须明确的处理值为空的情况。只要一个值不是 `Option<T>` 类型，你就 **可以** 安全的认定它的值不为空。**也就是从语法的层面上强制程序员事先对可能出现空值的地方进行处理。**
